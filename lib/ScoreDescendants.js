"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scoreDescendants = scoreDescendants;

var _ScoreAndClaimEdge = require("./dataModels/ScoreAndClaimEdge");

var _FindScopes = require("./FindScopes");

var _calculateScore = require("./calculateScore");

var _Id = require("./dataModels/Id");

var _Score = require("./dataModels/Score");

var _Change = require("./dataModels/Change");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function scoreDescendants(repo, parentId, ScopeId) {
  var claimEdges = repo.getClaimEdgesByParentId(parentId);
  var scoreAndClaimEdges = [];
  claimEdges.forEach(function (claimEdge) {
    var claimEdgeScores = repo.getScoresByClaimId(claimEdge.childId); // If none of the scores exist then we need to generate them

    if (claimEdgeScores.length == 0) {
      scoreDescendants(repo, claimEdge.childId, claimEdge.scopeId);
      claimEdgeScores = repo.getScoresByClaimId(claimEdge.childId);
    }

    claimEdgeScores.forEach(function (score) {
      scoreAndClaimEdges.push(new _ScoreAndClaimEdge.ScoreAndClaimEdge(score, claimEdge));
    });
  });
  var scoreAndClaimEdgesByScoreScopeIds = (0, _FindScopes.FindScopes)(scoreAndClaimEdges); //Check each Scope and ClaimEdge and create any missing scores

  Object.entries(scoreAndClaimEdgesByScoreScopeIds).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        scopeIdString = _ref2[0];

    claimEdges.forEach(function (claimEdge) {
      if (scoreAndClaimEdgesByScoreScopeIds[scopeIdString].find(function (sce) {
        return sce.claimEdge == claimEdge;
      }) == undefined) {
        //Look for already existing scores
        var foundScore = repo.getScoreByClaimIdAndScope(claimEdge.childId, (0, _Id.ID)(scopeIdString));
        scoreAndClaimEdgesByScoreScopeIds[scopeIdString].push(new _ScoreAndClaimEdge.ScoreAndClaimEdge(foundScore, claimEdge));
      }
    });
  }); //For each scope, loop through and create a score

  Object.entries(scoreAndClaimEdgesByScoreScopeIds).forEach(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        scopeIdString = _ref4[0],
        scoreAndClaimEdges = _ref4[1];

    var newScore = (0, _calculateScore.calculateScore)(scoreAndClaimEdges);
    newScore.scopeId = (0, _Id.ID)(scopeIdString);
    newScore.sourceClaimId = scoreAndClaimEdges[0].claimEdge.parentId; //ToDo: Is there a better way to get this?

    repo.notify([new _Change.Change(newScore)]);
  }); //If there are no edges below it then create a base score

  if (claimEdges.length === 0) {
    repo.notify([new _Change.Change(new _Score.Score(undefined, undefined, undefined, parentId, ScopeId))]);
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TY29yZURlc2NlbmRhbnRzLnRzIl0sIm5hbWVzIjpbInNjb3JlRGVzY2VuZGFudHMiLCJyZXBvIiwicGFyZW50SWQiLCJTY29wZUlkIiwiY2xhaW1FZGdlcyIsImdldENsYWltRWRnZXNCeVBhcmVudElkIiwic2NvcmVBbmRDbGFpbUVkZ2VzIiwiZm9yRWFjaCIsImNsYWltRWRnZSIsImNsYWltRWRnZVNjb3JlcyIsImdldFNjb3Jlc0J5Q2xhaW1JZCIsImNoaWxkSWQiLCJsZW5ndGgiLCJzY29wZUlkIiwic2NvcmUiLCJwdXNoIiwiU2NvcmVBbmRDbGFpbUVkZ2UiLCJzY29yZUFuZENsYWltRWRnZXNCeVNjb3JlU2NvcGVJZHMiLCJPYmplY3QiLCJlbnRyaWVzIiwic2NvcGVJZFN0cmluZyIsImZpbmQiLCJzY2UiLCJ1bmRlZmluZWQiLCJmb3VuZFNjb3JlIiwiZ2V0U2NvcmVCeUNsYWltSWRBbmRTY29wZSIsIm5ld1Njb3JlIiwic291cmNlQ2xhaW1JZCIsIm5vdGlmeSIsIkNoYW5nZSIsIlNjb3JlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFFTyxTQUFTQSxnQkFBVCxDQUEwQkMsSUFBMUIsRUFBNENDLFFBQTVDLEVBQTBEQyxPQUExRCxFQUE4RTtBQUNqRixNQUFNQyxVQUFVLEdBQUdILElBQUksQ0FBQ0ksdUJBQUwsQ0FBNkJILFFBQTdCLENBQW5CO0FBQ0EsTUFBTUksa0JBQXVDLEdBQUcsRUFBaEQ7QUFFQUYsRUFBQUEsVUFBVSxDQUFDRyxPQUFYLENBQW1CLFVBQUNDLFNBQUQsRUFBZTtBQUM5QixRQUFJQyxlQUFlLEdBQUdSLElBQUksQ0FBQ1Msa0JBQUwsQ0FBd0JGLFNBQVMsQ0FBQ0csT0FBbEMsQ0FBdEIsQ0FEOEIsQ0FFOUI7O0FBQ0EsUUFBSUYsZUFBZSxDQUFDRyxNQUFoQixJQUEwQixDQUE5QixFQUFpQztBQUM3QlosTUFBQUEsZ0JBQWdCLENBQUNDLElBQUQsRUFBT08sU0FBUyxDQUFDRyxPQUFqQixFQUEwQkgsU0FBUyxDQUFDSyxPQUFwQyxDQUFoQjtBQUNBSixNQUFBQSxlQUFlLEdBQUdSLElBQUksQ0FBQ1Msa0JBQUwsQ0FBd0JGLFNBQVMsQ0FBQ0csT0FBbEMsQ0FBbEI7QUFDSDs7QUFDREYsSUFBQUEsZUFBZSxDQUFDRixPQUFoQixDQUF3QixVQUFDTyxLQUFELEVBQVc7QUFDL0JSLE1BQUFBLGtCQUFrQixDQUFDUyxJQUFuQixDQUNJLElBQUlDLG9DQUFKLENBQXNCRixLQUF0QixFQUE2Qk4sU0FBN0IsQ0FESjtBQUdILEtBSkQ7QUFLSCxHQVpEO0FBY0EsTUFBTVMsaUNBQWlDLEdBQUcsNEJBQVdYLGtCQUFYLENBQTFDLENBbEJpRixDQW9CakY7O0FBQ0FZLEVBQUFBLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlRixpQ0FBZixFQUFrRFYsT0FBbEQsQ0FBMEQsZ0JBQXFCO0FBQUE7QUFBQSxRQUFuQmEsYUFBbUI7O0FBQzNFaEIsSUFBQUEsVUFBVSxDQUFDRyxPQUFYLENBQW1CLFVBQUNDLFNBQUQsRUFBZTtBQUM5QixVQUFJUyxpQ0FBaUMsQ0FBQ0csYUFBRCxDQUFqQyxDQUFpREMsSUFBakQsQ0FDQSxVQUFBQyxHQUFHO0FBQUEsZUFBSUEsR0FBRyxDQUFDZCxTQUFKLElBQWlCQSxTQUFyQjtBQUFBLE9BREgsS0FDc0NlLFNBRDFDLEVBQ3FEO0FBQ2pEO0FBQ0EsWUFBTUMsVUFBVSxHQUFHdkIsSUFBSSxDQUFDd0IseUJBQUwsQ0FBK0JqQixTQUFTLENBQUNHLE9BQXpDLEVBQWtELFlBQUdTLGFBQUgsQ0FBbEQsQ0FBbkI7QUFDQUgsUUFBQUEsaUNBQWlDLENBQUNHLGFBQUQsQ0FBakMsQ0FBaURMLElBQWpELENBQ0ksSUFBSUMsb0NBQUosQ0FBc0JRLFVBQXRCLEVBQWtDaEIsU0FBbEMsQ0FESjtBQUdIO0FBQ0osS0FURDtBQVVILEdBWEQsRUFyQmlGLENBa0NqRjs7QUFDQVUsRUFBQUEsTUFBTSxDQUFDQyxPQUFQLENBQWVGLGlDQUFmLEVBQWtEVixPQUFsRCxDQUEwRCxpQkFBeUM7QUFBQTtBQUFBLFFBQXZDYSxhQUF1QztBQUFBLFFBQXhCZCxrQkFBd0I7O0FBQy9GLFFBQU1vQixRQUFRLEdBQUcsb0NBQWVwQixrQkFBZixDQUFqQjtBQUNBb0IsSUFBQUEsUUFBUSxDQUFDYixPQUFULEdBQW1CLFlBQUdPLGFBQUgsQ0FBbkI7QUFDQU0sSUFBQUEsUUFBUSxDQUFDQyxhQUFULEdBQXlCckIsa0JBQWtCLENBQUMsQ0FBRCxDQUFsQixDQUFzQkUsU0FBdEIsQ0FBZ0NOLFFBQXpELENBSCtGLENBRzVCOztBQUNuRUQsSUFBQUEsSUFBSSxDQUFDMkIsTUFBTCxDQUFZLENBQUMsSUFBSUMsY0FBSixDQUFXSCxRQUFYLENBQUQsQ0FBWjtBQUNILEdBTEQsRUFuQ2lGLENBMENqRjs7QUFDQSxNQUFJdEIsVUFBVSxDQUFDUSxNQUFYLEtBQXNCLENBQTFCLEVBQTZCO0FBQ3pCWCxJQUFBQSxJQUFJLENBQUMyQixNQUFMLENBQVksQ0FBQyxJQUFJQyxjQUFKLENBQ1QsSUFBSUMsWUFBSixDQUFVUCxTQUFWLEVBQXFCQSxTQUFyQixFQUFnQ0EsU0FBaEMsRUFBMkNyQixRQUEzQyxFQUFxREMsT0FBckQsQ0FEUyxDQUFELENBQVo7QUFJSDtBQUVKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVwb3NpdG9yeSB9IGZyb20gXCIuL1JlcG9zaXRvcnlcIjtcbmltcG9ydCB7IFNjb3JlQW5kQ2xhaW1FZGdlIH0gZnJvbSBcIi4vZGF0YU1vZGVscy9TY29yZUFuZENsYWltRWRnZVwiO1xuaW1wb3J0IHsgRmluZFNjb3BlcyB9IGZyb20gXCIuL0ZpbmRTY29wZXNcIjtcbmltcG9ydCB7IGNhbGN1bGF0ZVNjb3JlIH0gZnJvbSBcIi4vY2FsY3VsYXRlU2NvcmVcIjtcbmltcG9ydCB7IElELCBJZCB9IGZyb20gXCIuL2RhdGFNb2RlbHMvSWRcIjtcbmltcG9ydCB7IFNjb3JlIH0gZnJvbSBcIi4vZGF0YU1vZGVscy9TY29yZVwiO1xuaW1wb3J0IHsgQ2hhbmdlIH0gZnJvbSBcIi4vZGF0YU1vZGVscy9DaGFuZ2VcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNjb3JlRGVzY2VuZGFudHMocmVwbzogUmVwb3NpdG9yeSwgcGFyZW50SWQ6IElkLCBTY29wZUlkPzogSWQpOiB2b2lkIHtcbiAgICBjb25zdCBjbGFpbUVkZ2VzID0gcmVwby5nZXRDbGFpbUVkZ2VzQnlQYXJlbnRJZChwYXJlbnRJZCk7XG4gICAgY29uc3Qgc2NvcmVBbmRDbGFpbUVkZ2VzOiBTY29yZUFuZENsYWltRWRnZVtdID0gW107XG5cbiAgICBjbGFpbUVkZ2VzLmZvckVhY2goKGNsYWltRWRnZSkgPT4ge1xuICAgICAgICBsZXQgY2xhaW1FZGdlU2NvcmVzID0gcmVwby5nZXRTY29yZXNCeUNsYWltSWQoY2xhaW1FZGdlLmNoaWxkSWQpO1xuICAgICAgICAvLyBJZiBub25lIG9mIHRoZSBzY29yZXMgZXhpc3QgdGhlbiB3ZSBuZWVkIHRvIGdlbmVyYXRlIHRoZW1cbiAgICAgICAgaWYgKGNsYWltRWRnZVNjb3Jlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgc2NvcmVEZXNjZW5kYW50cyhyZXBvLCBjbGFpbUVkZ2UuY2hpbGRJZCwgY2xhaW1FZGdlLnNjb3BlSWQpXG4gICAgICAgICAgICBjbGFpbUVkZ2VTY29yZXMgPSByZXBvLmdldFNjb3Jlc0J5Q2xhaW1JZChjbGFpbUVkZ2UuY2hpbGRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2xhaW1FZGdlU2NvcmVzLmZvckVhY2goKHNjb3JlKSA9PiB7XG4gICAgICAgICAgICBzY29yZUFuZENsYWltRWRnZXMucHVzaChcbiAgICAgICAgICAgICAgICBuZXcgU2NvcmVBbmRDbGFpbUVkZ2Uoc2NvcmUsIGNsYWltRWRnZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc2NvcmVBbmRDbGFpbUVkZ2VzQnlTY29yZVNjb3BlSWRzID0gRmluZFNjb3BlcyhzY29yZUFuZENsYWltRWRnZXMpO1xuXG4gICAgLy9DaGVjayBlYWNoIFNjb3BlIGFuZCBDbGFpbUVkZ2UgYW5kIGNyZWF0ZSBhbnkgbWlzc2luZyBzY29yZXNcbiAgICBPYmplY3QuZW50cmllcyhzY29yZUFuZENsYWltRWRnZXNCeVNjb3JlU2NvcGVJZHMpLmZvckVhY2goKFtzY29wZUlkU3RyaW5nXSkgPT4ge1xuICAgICAgICBjbGFpbUVkZ2VzLmZvckVhY2goKGNsYWltRWRnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjb3JlQW5kQ2xhaW1FZGdlc0J5U2NvcmVTY29wZUlkc1tzY29wZUlkU3RyaW5nXS5maW5kKFxuICAgICAgICAgICAgICAgIHNjZSA9PiBzY2UuY2xhaW1FZGdlID09IGNsYWltRWRnZSkgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy9Mb29rIGZvciBhbHJlYWR5IGV4aXN0aW5nIHNjb3Jlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kU2NvcmUgPSByZXBvLmdldFNjb3JlQnlDbGFpbUlkQW5kU2NvcGUoY2xhaW1FZGdlLmNoaWxkSWQsIElEKHNjb3BlSWRTdHJpbmcpKVxuICAgICAgICAgICAgICAgIHNjb3JlQW5kQ2xhaW1FZGdlc0J5U2NvcmVTY29wZUlkc1tzY29wZUlkU3RyaW5nXS5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBuZXcgU2NvcmVBbmRDbGFpbUVkZ2UoZm91bmRTY29yZSwgY2xhaW1FZGdlKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvL0ZvciBlYWNoIHNjb3BlLCBsb29wIHRocm91Z2ggYW5kIGNyZWF0ZSBhIHNjb3JlXG4gICAgT2JqZWN0LmVudHJpZXMoc2NvcmVBbmRDbGFpbUVkZ2VzQnlTY29yZVNjb3BlSWRzKS5mb3JFYWNoKChbc2NvcGVJZFN0cmluZywgc2NvcmVBbmRDbGFpbUVkZ2VzXSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdTY29yZSA9IGNhbGN1bGF0ZVNjb3JlKHNjb3JlQW5kQ2xhaW1FZGdlcyk7XG4gICAgICAgIG5ld1Njb3JlLnNjb3BlSWQgPSBJRChzY29wZUlkU3RyaW5nKTtcbiAgICAgICAgbmV3U2NvcmUuc291cmNlQ2xhaW1JZCA9IHNjb3JlQW5kQ2xhaW1FZGdlc1swXS5jbGFpbUVkZ2UucGFyZW50SWQ7IC8vVG9EbzogSXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGdldCB0aGlzP1xuICAgICAgICByZXBvLm5vdGlmeShbbmV3IENoYW5nZShuZXdTY29yZSldKTtcbiAgICB9KTtcblxuICAgIC8vSWYgdGhlcmUgYXJlIG5vIGVkZ2VzIGJlbG93IGl0IHRoZW4gY3JlYXRlIGEgYmFzZSBzY29yZVxuICAgIGlmIChjbGFpbUVkZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXBvLm5vdGlmeShbbmV3IENoYW5nZShcbiAgICAgICAgICAgIG5ldyBTY29yZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBwYXJlbnRJZCwgU2NvcGVJZClcbiAgICAgICAgKV0pO1xuXG4gICAgfVxuXG59Il19