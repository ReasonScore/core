"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateScoreActions = calculateScoreActions;

var _Score = require("./dataModels/Score");

var _Action = require("./dataModels/Action");

var _calculateScore = require("./calculateScore");

var _RepositoryLocalPure = require("./repositories/RepositoryLocalPure");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Calculates the score actions based on a list of actions
 */
async function calculateScoreActions({
  actions = [],
  repository = new _RepositoryLocalPure.RepositoryLocalPure(),
  calculator = _calculateScore.calculateScore
} = {}) {
  const scoreActions = [];
  const claimIdsToScore = [];
  const ScoreTreeIds = [];
  await repository.notify(actions);

  for (const action of actions) {
    // find claims that may need scores changed
    if (action.type == 'add_claim' || action.type == 'modify_claim') {
      claimIdsToScore.push(action.dataId);
    }

    if (action.type == "add_score") {
      let score = action.newData;

      if (!score.parentId) {
        const scoreTemp = await repository.getScore(action.dataId);

        if (scoreTemp) {
          score = scoreTemp;
        }
      }

      claimIdsToScore.push(score.sourceClaimId);
    } //Add scores if edges adds new children to claims in score trees


    if (action.type == 'add_claimEdge' || action.type == 'modify_claimEdge') {
      let claimEdge = action.newData;

      if (!claimEdge.parentId) {
        const claimEdgeTemp = await repository.getClaimEdge(action.dataId);

        if (claimEdgeTemp) {
          claimEdge = claimEdgeTemp;
        }
      }

      claimIdsToScore.push(claimEdge.parentId);
    } //TODO: If an edge changes then modify the existing scores to match


    if (action.type == 'modify_claimEdge') {
      let claimEdge = await repository.getClaimEdge(action.dataId);
      claimEdge = _objectSpread({}, claimEdge, {}, action.newData);

      if (claimEdge) {
        action.newData;
        const scores = await repository.getScoresBySourceId(claimEdge.id);

        for (const score of scores) {
          //TODO: Where should I put this? It is modifying am object. If it is reactive i should just change the data. If pure it should be a new object.
          //For now I will modify it but it may not trigger updates in a pure library (React)
          //This change should also probably be centralized somewhere to reduce the chance of inconsistent bugs. I think it will happen in multiple paces
          //Nope, it is an action so it should always be a new object. If it goes into a reactive respoitory then it will modify the actual object
          //Should I group these actions or just throw them in one at a time like I am doing
          if (score.pro != claimEdge.pro || score.affects != claimEdge.affects) {
            const action = new _Action.Action({
              pro: claimEdge.pro,
              affects: claimEdge.affects,
              priority: claimEdge.priority
            }, score, "modify_score", score.id);
            scoreActions.push(action);
            await repository.notify([action]);
          }
        }
      }
    }

    if (action.type == 'delete_claimEdge') {
      const oldClaimEdge = action.oldData;
      claimIdsToScore.push(oldClaimEdge.parentId);
    }

    if (action.type == 'add_scoreTree') {
      const scoreTree = action.newData;
      ScoreTreeIds.push(scoreTree.id);
    }
  } //Walk up the scores for each claim to the top


  for (const claimId of claimIdsToScore) {
    for (const claimScore of await repository.getScoresBySourceId(claimId)) {
      ScoreTreeIds.push(claimScore.scoreTreeId);
    }
  } //Re-calc all Score Trees with possible changed claims


  for (const scoreTreeId of ScoreTreeIds) {
    const scoreTree = await repository.getScoreTree(scoreTreeId);

    if (scoreTree) {
      const tempMissingScoreActions = [];
      let topScore = await repository.getScore(scoreTree.topScoreId);

      if (!topScore) {
        topScore = new _Score.Score(scoreTree.sourceClaimId, scoreTree.id);
        topScore.id = scoreTree.topScoreId;
        tempMissingScoreActions.push(new _Action.Action(topScore, undefined, "add_score"));
      }

      await createBlankMissingScores(repository, scoreTree.topScoreId, scoreTree.sourceClaimId || "", tempMissingScoreActions, scoreTreeId);

      if (tempMissingScoreActions.length > 0) {
        await repository.notify(tempMissingScoreActions);
      }

      const tempcalculateScoreTreeActions = [];
      await calculateScoreTree(repository, topScore, calculator, tempMissingScoreActions);
      scoreActions.push(...tempMissingScoreActions, ...tempcalculateScoreTreeActions);
    }
  } //TODO: Review this decision: Feed the score actions back into the repository so this repository is up to date in case it is used 


  await repository.notify(scoreActions);
  return scoreActions;
} //Create Blank Missing Scores


async function createBlankMissingScores(repository, currentScoreId, currentClaimId, actions, scoreTreeId) {
  const edges = await repository.getClaimEdgesByParentId(currentClaimId);
  const scores = await repository.getChildrenByScoreId(currentScoreId);

  for (const edge of edges) {
    //see if there is a matching child score for the child edge
    let score = scores.find(({
      sourceClaimId
    }) => sourceClaimId === edge.childId);

    if (!score) {
      //Create a new Score and attach it to it's parent
      const u = undefined;
      score = new _Score.Score(edge.childId, scoreTreeId, currentScoreId, edge.id, undefined, edge.pro, edge.affects, u, u, u, edge.priority);
      actions.push(new _Action.Action(score, undefined, "add_score", score.id));
    } //Recurse and through children


    await createBlankMissingScores(repository, score.id, edge.childId, actions, scoreTreeId);
  }
} //This function assume that all scores already exist


async function calculateScoreTree(repository, currentScore, calculator = _calculateScore.calculateScore, actions) {
  const oldScores = await repository.getChildrenByScoreId(currentScore.id);
  const newScores = [];

  for (const oldScore of oldScores) {
    //Calculate Children
    //TODO: remove any scores to calculate based on formulas that exclude scores
    newScores.push((await calculateScoreTree(repository, oldScore, calculator, actions)));
  }

  const newScoreFragment = calculator({
    childScores: newScores,
    reversible: currentScore.reversible
  }); //TODO: Modify the newScore based on any formulas

  const newScore = _objectSpread({}, currentScore, {}, newScoreFragment);

  if ((0, _Score.differentScores)(currentScore, newScore)) {
    actions.push(new _Action.Action(newScore, undefined, "modify_score", newScore.id));
  }

  return newScore;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jYWxjdWxhdGVTY29yZUFjdGlvbnMudHMiXSwibmFtZXMiOlsiY2FsY3VsYXRlU2NvcmVBY3Rpb25zIiwiYWN0aW9ucyIsInJlcG9zaXRvcnkiLCJSZXBvc2l0b3J5TG9jYWxQdXJlIiwiY2FsY3VsYXRvciIsImNhbGN1bGF0ZVNjb3JlIiwic2NvcmVBY3Rpb25zIiwiY2xhaW1JZHNUb1Njb3JlIiwiU2NvcmVUcmVlSWRzIiwibm90aWZ5IiwiYWN0aW9uIiwidHlwZSIsInB1c2giLCJkYXRhSWQiLCJzY29yZSIsIm5ld0RhdGEiLCJwYXJlbnRJZCIsInNjb3JlVGVtcCIsImdldFNjb3JlIiwic291cmNlQ2xhaW1JZCIsImNsYWltRWRnZSIsImNsYWltRWRnZVRlbXAiLCJnZXRDbGFpbUVkZ2UiLCJzY29yZXMiLCJnZXRTY29yZXNCeVNvdXJjZUlkIiwiaWQiLCJwcm8iLCJhZmZlY3RzIiwiQWN0aW9uIiwicHJpb3JpdHkiLCJvbGRDbGFpbUVkZ2UiLCJvbGREYXRhIiwic2NvcmVUcmVlIiwiY2xhaW1JZCIsImNsYWltU2NvcmUiLCJzY29yZVRyZWVJZCIsImdldFNjb3JlVHJlZSIsInRlbXBNaXNzaW5nU2NvcmVBY3Rpb25zIiwidG9wU2NvcmUiLCJ0b3BTY29yZUlkIiwiU2NvcmUiLCJ1bmRlZmluZWQiLCJjcmVhdGVCbGFua01pc3NpbmdTY29yZXMiLCJsZW5ndGgiLCJ0ZW1wY2FsY3VsYXRlU2NvcmVUcmVlQWN0aW9ucyIsImNhbGN1bGF0ZVNjb3JlVHJlZSIsImN1cnJlbnRTY29yZUlkIiwiY3VycmVudENsYWltSWQiLCJlZGdlcyIsImdldENsYWltRWRnZXNCeVBhcmVudElkIiwiZ2V0Q2hpbGRyZW5CeVNjb3JlSWQiLCJlZGdlIiwiZmluZCIsImNoaWxkSWQiLCJ1IiwiY3VycmVudFNjb3JlIiwib2xkU2NvcmVzIiwibmV3U2NvcmVzIiwib2xkU2NvcmUiLCJuZXdTY29yZUZyYWdtZW50IiwiY2hpbGRTY29yZXMiLCJyZXZlcnNpYmxl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VSxrQkFBZixDQUFrQzNDLFVBQWxDLEVBQTJEcUQsWUFBM0QsRUFBaUZuRCxVQUEyQixHQUFHQyw4QkFBL0csRUFBK0hKLE9BQS9ILEVBQWtKO0FBQzlJLFFBQU11RCxTQUFTLEdBQUcsTUFBTXRELFVBQVUsQ0FBQ2dELG9CQUFYLENBQWdDSyxZQUFZLENBQUM5QixFQUE3QyxDQUF4QjtBQUNBLFFBQU1nQyxTQUFtQixHQUFHLEVBQTVCOztBQUVBLE9BQUssTUFBTUMsUUFBWCxJQUF1QkYsU0FBdkIsRUFBa0M7QUFBRTtBQUNoQztBQUNBQyxJQUFBQSxTQUFTLENBQUM3QyxJQUFWLEVBQWUsTUFBTWlDLGtCQUFrQixDQUFDM0MsVUFBRCxFQUFhd0QsUUFBYixFQUF1QnRELFVBQXZCLEVBQW1DSCxPQUFuQyxDQUF2QztBQUNIOztBQUVELFFBQU0wRCxnQkFBZ0IsR0FBR3ZELFVBQVUsQ0FBQztBQUNoQ3dELElBQUFBLFdBQVcsRUFBRUgsU0FEbUI7QUFFaENJLElBQUFBLFVBQVUsRUFBRU4sWUFBWSxDQUFDTTtBQUZPLEdBQUQsQ0FBbkMsQ0FUOEksQ0FjOUk7O0FBQ0EsUUFBTUMsUUFBUSxxQkFBUVAsWUFBUixNQUF5QkksZ0JBQXpCLENBQWQ7O0FBQ0EsTUFBSSw0QkFBZ0JKLFlBQWhCLEVBQThCTyxRQUE5QixDQUFKLEVBQTZDO0FBQ3pDN0QsSUFBQUEsT0FBTyxDQUFDVyxJQUFSLENBQWEsSUFBSWdCLGNBQUosQ0FBV2tDLFFBQVgsRUFBcUJyQixTQUFyQixFQUFnQyxjQUFoQyxFQUFnRHFCLFFBQVEsQ0FBQ3JDLEVBQXpELENBQWI7QUFDSDs7QUFDRCxTQUFPcUMsUUFBUDtBQUNIIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2NvcmUsIGRpZmZlcmVudFNjb3JlcywgaVNjb3JlIH0gZnJvbSBcIi4vZGF0YU1vZGVscy9TY29yZVwiO1xyXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tIFwiLi9kYXRhTW9kZWxzL0FjdGlvblwiO1xyXG5pbXBvcnQgeyBpQ2FsY3VsYXRlU2NvcmUsIGNhbGN1bGF0ZVNjb3JlIH0gZnJvbSBcIi4vY2FsY3VsYXRlU2NvcmVcIjtcclxuaW1wb3J0IHsgaVJlcG9zaXRvcnkgfSBmcm9tIFwiLi9kYXRhTW9kZWxzL2lSZXBvc2l0b3J5XCI7XHJcbmltcG9ydCB7IENsYWltRWRnZSwgaUNsYWltRWRnZSB9IGZyb20gXCIuL2RhdGFNb2RlbHMvQ2xhaW1FZGdlXCI7XHJcbmltcG9ydCB7IFJlcG9zaXRvcnlMb2NhbFB1cmUgfSBmcm9tIFwiLi9yZXBvc2l0b3JpZXMvUmVwb3NpdG9yeUxvY2FsUHVyZVwiO1xyXG5pbXBvcnQgeyBTY29yZVRyZWUgfSBmcm9tIFwiLlwiO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNjb3JlIGFjdGlvbnMgYmFzZWQgb24gYSBsaXN0IG9mIGFjdGlvbnNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVTY29yZUFjdGlvbnMoeyBhY3Rpb25zID0gW10sIHJlcG9zaXRvcnkgPSBuZXcgUmVwb3NpdG9yeUxvY2FsUHVyZSgpLCBjYWxjdWxhdG9yID0gY2FsY3VsYXRlU2NvcmUgfToge1xyXG4gICAgLyoqIEFuIGFycmF5IG9mIGFjdGlvbnMsIHVzdWFsbHkgb24gY2xhaW1zIG9yIGVkZ2VzIHRoYXQgaW5jbHVzZSBubyBzY29yZXMqL1xyXG4gICAgYWN0aW9ucz86IEFjdGlvbltdO1xyXG4gICAgLyoqIFRoZSByZXBvc2l0b3J5IHVzZWQgdG8gZ2V0IGNvbnRleHQgZm9yIHRoZSBhY3Rpb25zICovXHJcbiAgICByZXBvc2l0b3J5PzogaVJlcG9zaXRvcnk7XHJcbiAgICAvKiogVGhlIGZ1bmN0aW9uIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBzY29yZXMgKi9cclxuICAgIGNhbGN1bGF0b3I/OiBpQ2FsY3VsYXRlU2NvcmU7XHJcbn0gPSB7fSxcclxuKSB7XHJcbiAgICBjb25zdCBzY29yZUFjdGlvbnM6IEFjdGlvbltdID0gW107XHJcbiAgICBjb25zdCBjbGFpbUlkc1RvU2NvcmU6IHN0cmluZ1tdID0gW107XHJcbiAgICBjb25zdCBTY29yZVRyZWVJZHM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgYXdhaXQgcmVwb3NpdG9yeS5ub3RpZnkoYWN0aW9ucyk7XHJcbiAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XHJcblxyXG4gICAgICAgIC8vIGZpbmQgY2xhaW1zIHRoYXQgbWF5IG5lZWQgc2NvcmVzIGNoYW5nZWRcclxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT0gJ2FkZF9jbGFpbScgfHwgYWN0aW9uLnR5cGUgPT0gJ21vZGlmeV9jbGFpbScpIHtcclxuICAgICAgICAgICAgY2xhaW1JZHNUb1Njb3JlLnB1c2goYWN0aW9uLmRhdGFJZClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PSBcImFkZF9zY29yZVwiKSB7XHJcbiAgICAgICAgICAgIGxldCBzY29yZSA9IGFjdGlvbi5uZXdEYXRhIGFzIGlTY29yZTtcclxuICAgICAgICAgICAgaWYgKCFzY29yZS5wYXJlbnRJZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvcmVUZW1wID0gYXdhaXQgcmVwb3NpdG9yeS5nZXRTY29yZShhY3Rpb24uZGF0YUlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKHNjb3JlVGVtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlID0gc2NvcmVUZW1wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjbGFpbUlkc1RvU2NvcmUucHVzaChzY29yZS5zb3VyY2VDbGFpbUlkKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9BZGQgc2NvcmVzIGlmIGVkZ2VzIGFkZHMgbmV3IGNoaWxkcmVuIHRvIGNsYWltcyBpbiBzY29yZSB0cmVlc1xyXG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PSAnYWRkX2NsYWltRWRnZScgfHwgYWN0aW9uLnR5cGUgPT0gJ21vZGlmeV9jbGFpbUVkZ2UnKSB7XHJcbiAgICAgICAgICAgIGxldCBjbGFpbUVkZ2UgPSBhY3Rpb24ubmV3RGF0YSBhcyBpQ2xhaW1FZGdlO1xyXG4gICAgICAgICAgICBpZiAoIWNsYWltRWRnZS5wYXJlbnRJZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xhaW1FZGdlVGVtcCA9IGF3YWl0IHJlcG9zaXRvcnkuZ2V0Q2xhaW1FZGdlKGFjdGlvbi5kYXRhSWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoY2xhaW1FZGdlVGVtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYWltRWRnZSA9IGNsYWltRWRnZVRlbXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2xhaW1JZHNUb1Njb3JlLnB1c2goY2xhaW1FZGdlLnBhcmVudElkKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9UT0RPOiBJZiBhbiBlZGdlIGNoYW5nZXMgdGhlbiBtb2RpZnkgdGhlIGV4aXN0aW5nIHNjb3JlcyB0byBtYXRjaFxyXG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PSAnbW9kaWZ5X2NsYWltRWRnZScpIHtcclxuICAgICAgICAgICAgbGV0IGNsYWltRWRnZSA9IGF3YWl0IHJlcG9zaXRvcnkuZ2V0Q2xhaW1FZGdlKGFjdGlvbi5kYXRhSWQpXHJcbiAgICAgICAgICAgIGNsYWltRWRnZSA9IHsgLi4uY2xhaW1FZGdlLCAuLi5hY3Rpb24ubmV3RGF0YSB9XHJcbiAgICAgICAgICAgIGlmIChjbGFpbUVkZ2UpIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbi5uZXdEYXRhIGFzIENsYWltRWRnZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjb3JlcyA9IGF3YWl0IHJlcG9zaXRvcnkuZ2V0U2NvcmVzQnlTb3VyY2VJZChjbGFpbUVkZ2UuaWQpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNjb3JlIG9mIHNjb3Jlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETzogV2hlcmUgc2hvdWxkIEkgcHV0IHRoaXM/IEl0IGlzIG1vZGlmeWluZyBhbSBvYmplY3QuIElmIGl0IGlzIHJlYWN0aXZlIGkgc2hvdWxkIGp1c3QgY2hhbmdlIHRoZSBkYXRhLiBJZiBwdXJlIGl0IHNob3VsZCBiZSBhIG5ldyBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9Gb3Igbm93IEkgd2lsbCBtb2RpZnkgaXQgYnV0IGl0IG1heSBub3QgdHJpZ2dlciB1cGRhdGVzIGluIGEgcHVyZSBsaWJyYXJ5IChSZWFjdClcclxuICAgICAgICAgICAgICAgICAgICAvL1RoaXMgY2hhbmdlIHNob3VsZCBhbHNvIHByb2JhYmx5IGJlIGNlbnRyYWxpemVkIHNvbWV3aGVyZSB0byByZWR1Y2UgdGhlIGNoYW5jZSBvZiBpbmNvbnNpc3RlbnQgYnVncy4gSSB0aGluayBpdCB3aWxsIGhhcHBlbiBpbiBtdWx0aXBsZSBwYWNlc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vTm9wZSwgaXQgaXMgYW4gYWN0aW9uIHNvIGl0IHNob3VsZCBhbHdheXMgYmUgYSBuZXcgb2JqZWN0LiBJZiBpdCBnb2VzIGludG8gYSByZWFjdGl2ZSByZXNwb2l0b3J5IHRoZW4gaXQgd2lsbCBtb2RpZnkgdGhlIGFjdHVhbCBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAvL1Nob3VsZCBJIGdyb3VwIHRoZXNlIGFjdGlvbnMgb3IganVzdCB0aHJvdyB0aGVtIGluIG9uZSBhdCBhIHRpbWUgbGlrZSBJIGFtIGRvaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3JlLnBybyAhPSBjbGFpbUVkZ2UucHJvIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlLmFmZmVjdHMgIT0gY2xhaW1FZGdlLmFmZmVjdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWN0aW9uID0gbmV3IEFjdGlvbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm86IGNsYWltRWRnZS5wcm8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RzOiBjbGFpbUVkZ2UuYWZmZWN0cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBjbGFpbUVkZ2UucHJpb3JpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNjb3JlLCBcIm1vZGlmeV9zY29yZVwiLCBzY29yZS5pZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVBY3Rpb25zLnB1c2goYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVwb3NpdG9yeS5ub3RpZnkoW2FjdGlvbl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09ICdkZWxldGVfY2xhaW1FZGdlJykge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRDbGFpbUVkZ2UgPSBhY3Rpb24ub2xkRGF0YSBhcyBDbGFpbUVkZ2U7XHJcbiAgICAgICAgICAgIGNsYWltSWRzVG9TY29yZS5wdXNoKG9sZENsYWltRWRnZS5wYXJlbnRJZClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PSAnYWRkX3Njb3JlVHJlZScpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2NvcmVUcmVlID0gYWN0aW9uLm5ld0RhdGEgYXMgU2NvcmVUcmVlO1xyXG4gICAgICAgICAgICBTY29yZVRyZWVJZHMucHVzaChzY29yZVRyZWUuaWQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIC8vV2FsayB1cCB0aGUgc2NvcmVzIGZvciBlYWNoIGNsYWltIHRvIHRoZSB0b3BcclxuICAgIGZvciAoY29uc3QgY2xhaW1JZCBvZiBjbGFpbUlkc1RvU2NvcmUpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNsYWltU2NvcmUgb2YgYXdhaXQgcmVwb3NpdG9yeS5nZXRTY29yZXNCeVNvdXJjZUlkKGNsYWltSWQpKSB7XHJcbiAgICAgICAgICAgICAgICBTY29yZVRyZWVJZHMucHVzaChjbGFpbVNjb3JlLnNjb3JlVHJlZUlkKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1JlLWNhbGMgYWxsIFNjb3JlIFRyZWVzIHdpdGggcG9zc2libGUgY2hhbmdlZCBjbGFpbXNcclxuICAgIGZvciAoY29uc3Qgc2NvcmVUcmVlSWQgb2YgU2NvcmVUcmVlSWRzKSB7XHJcbiAgICAgICAgY29uc3Qgc2NvcmVUcmVlID0gYXdhaXQgcmVwb3NpdG9yeS5nZXRTY29yZVRyZWUoc2NvcmVUcmVlSWQpXHJcbiAgICAgICAgaWYgKHNjb3JlVHJlZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ZW1wTWlzc2luZ1Njb3JlQWN0aW9uczogQWN0aW9uW10gPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGxldCB0b3BTY29yZSA9IGF3YWl0IHJlcG9zaXRvcnkuZ2V0U2NvcmUoc2NvcmVUcmVlLnRvcFNjb3JlSWQpO1xyXG4gICAgICAgICAgICBpZiAoIXRvcFNjb3JlKXtcclxuICAgICAgICAgICAgICAgIHRvcFNjb3JlID0gbmV3IFNjb3JlKHNjb3JlVHJlZS5zb3VyY2VDbGFpbUlkLHNjb3JlVHJlZS5pZCk7XHJcbiAgICAgICAgICAgICAgICB0b3BTY29yZS5pZCA9IHNjb3JlVHJlZS50b3BTY29yZUlkO1xyXG4gICAgICAgICAgICAgICAgdGVtcE1pc3NpbmdTY29yZUFjdGlvbnMucHVzaChuZXcgQWN0aW9uKHRvcFNjb3JlLHVuZGVmaW5lZCxcImFkZF9zY29yZVwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGF3YWl0IGNyZWF0ZUJsYW5rTWlzc2luZ1Njb3JlcyhyZXBvc2l0b3J5LCBzY29yZVRyZWUudG9wU2NvcmVJZCwgc2NvcmVUcmVlLnNvdXJjZUNsYWltSWQgfHwgXCJcIiwgdGVtcE1pc3NpbmdTY29yZUFjdGlvbnMsIHNjb3JlVHJlZUlkKVxyXG4gICAgICAgICAgICBpZiAodGVtcE1pc3NpbmdTY29yZUFjdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgcmVwb3NpdG9yeS5ub3RpZnkodGVtcE1pc3NpbmdTY29yZUFjdGlvbnMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdGVtcGNhbGN1bGF0ZVNjb3JlVHJlZUFjdGlvbnM6IEFjdGlvbltdID0gW107XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBjYWxjdWxhdGVTY29yZVRyZWUocmVwb3NpdG9yeSwgdG9wU2NvcmUsIGNhbGN1bGF0b3IsIHRlbXBNaXNzaW5nU2NvcmVBY3Rpb25zKTtcclxuICAgICAgICAgICAgc2NvcmVBY3Rpb25zLnB1c2goLi4udGVtcE1pc3NpbmdTY29yZUFjdGlvbnMsIC4uLnRlbXBjYWxjdWxhdGVTY29yZVRyZWVBY3Rpb25zKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1RPRE86IFJldmlldyB0aGlzIGRlY2lzaW9uOiBGZWVkIHRoZSBzY29yZSBhY3Rpb25zIGJhY2sgaW50byB0aGUgcmVwb3NpdG9yeSBzbyB0aGlzIHJlcG9zaXRvcnkgaXMgdXAgdG8gZGF0ZSBpbiBjYXNlIGl0IGlzIHVzZWQgXHJcbiAgICBhd2FpdCByZXBvc2l0b3J5Lm5vdGlmeShzY29yZUFjdGlvbnMpO1xyXG5cclxuICAgIHJldHVybiBzY29yZUFjdGlvbnM7XHJcbn1cclxuXHJcbi8vQ3JlYXRlIEJsYW5rIE1pc3NpbmcgU2NvcmVzXHJcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUJsYW5rTWlzc2luZ1Njb3JlcyhyZXBvc2l0b3J5OiBpUmVwb3NpdG9yeSwgY3VycmVudFNjb3JlSWQ6IHN0cmluZywgY3VycmVudENsYWltSWQ6IHN0cmluZywgYWN0aW9uczogQWN0aW9uW10sIHNjb3JlVHJlZUlkOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IGVkZ2VzID0gYXdhaXQgcmVwb3NpdG9yeS5nZXRDbGFpbUVkZ2VzQnlQYXJlbnRJZChjdXJyZW50Q2xhaW1JZClcclxuICAgIGNvbnN0IHNjb3JlcyA9IGF3YWl0IHJlcG9zaXRvcnkuZ2V0Q2hpbGRyZW5CeVNjb3JlSWQoY3VycmVudFNjb3JlSWQpXHJcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcclxuICAgICAgICAvL3NlZSBpZiB0aGVyZSBpcyBhIG1hdGNoaW5nIGNoaWxkIHNjb3JlIGZvciB0aGUgY2hpbGQgZWRnZVxyXG4gICAgICAgIGxldCBzY29yZSA9IHNjb3Jlcy5maW5kKCh7IHNvdXJjZUNsYWltSWQgfSkgPT4gc291cmNlQ2xhaW1JZCA9PT0gZWRnZS5jaGlsZElkKTtcclxuICAgICAgICBpZiAoIXNjb3JlKSB7XHJcbiAgICAgICAgICAgIC8vQ3JlYXRlIGEgbmV3IFNjb3JlIGFuZCBhdHRhY2ggaXQgdG8gaXQncyBwYXJlbnRcclxuICAgICAgICAgICAgY29uc3QgdSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgc2NvcmUgPSBuZXcgU2NvcmUoZWRnZS5jaGlsZElkLCBzY29yZVRyZWVJZCwgY3VycmVudFNjb3JlSWQsIGVkZ2UuaWQsIHVuZGVmaW5lZCwgZWRnZS5wcm8sIGVkZ2UuYWZmZWN0cyx1LHUsdSxlZGdlLnByaW9yaXR5KTtcclxuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKG5ldyBBY3Rpb24oc2NvcmUsIHVuZGVmaW5lZCwgXCJhZGRfc2NvcmVcIiwgc2NvcmUuaWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9SZWN1cnNlIGFuZCB0aHJvdWdoIGNoaWxkcmVuXHJcbiAgICAgICAgYXdhaXQgY3JlYXRlQmxhbmtNaXNzaW5nU2NvcmVzKHJlcG9zaXRvcnksIHNjb3JlLmlkLCBlZGdlLmNoaWxkSWQsIGFjdGlvbnMsIHNjb3JlVHJlZUlkKTtcclxuICAgIH1cclxufVxyXG5cclxuLy9UaGlzIGZ1bmN0aW9uIGFzc3VtZSB0aGF0IGFsbCBzY29yZXMgYWxyZWFkeSBleGlzdFxyXG5hc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVTY29yZVRyZWUocmVwb3NpdG9yeTogaVJlcG9zaXRvcnksIGN1cnJlbnRTY29yZTogaVNjb3JlLCBjYWxjdWxhdG9yOiBpQ2FsY3VsYXRlU2NvcmUgPSBjYWxjdWxhdGVTY29yZSwgYWN0aW9uczogQWN0aW9uW10pIHtcclxuICAgIGNvbnN0IG9sZFNjb3JlcyA9IGF3YWl0IHJlcG9zaXRvcnkuZ2V0Q2hpbGRyZW5CeVNjb3JlSWQoY3VycmVudFNjb3JlLmlkKVxyXG4gICAgY29uc3QgbmV3U2NvcmVzOiBpU2NvcmVbXSA9IFtdO1xyXG5cclxuICAgIGZvciAoY29uc3Qgb2xkU2NvcmUgb2Ygb2xkU2NvcmVzKSB7IC8vQ2FsY3VsYXRlIENoaWxkcmVuXHJcbiAgICAgICAgLy9UT0RPOiByZW1vdmUgYW55IHNjb3JlcyB0byBjYWxjdWxhdGUgYmFzZWQgb24gZm9ybXVsYXMgdGhhdCBleGNsdWRlIHNjb3Jlc1xyXG4gICAgICAgIG5ld1Njb3Jlcy5wdXNoKGF3YWl0IGNhbGN1bGF0ZVNjb3JlVHJlZShyZXBvc2l0b3J5LCBvbGRTY29yZSwgY2FsY3VsYXRvciwgYWN0aW9ucykpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5ld1Njb3JlRnJhZ21lbnQgPSBjYWxjdWxhdG9yKHtcclxuICAgICAgICBjaGlsZFNjb3JlczogbmV3U2NvcmVzLFxyXG4gICAgICAgIHJldmVyc2libGU6IGN1cnJlbnRTY29yZS5yZXZlcnNpYmxlLFxyXG4gICAgfSlcclxuXHJcbiAgICAvL1RPRE86IE1vZGlmeSB0aGUgbmV3U2NvcmUgYmFzZWQgb24gYW55IGZvcm11bGFzXHJcbiAgICBjb25zdCBuZXdTY29yZSA9IHsgLi4uY3VycmVudFNjb3JlLCAuLi5uZXdTY29yZUZyYWdtZW50IH1cclxuICAgIGlmIChkaWZmZXJlbnRTY29yZXMoY3VycmVudFNjb3JlLCBuZXdTY29yZSkpIHtcclxuICAgICAgICBhY3Rpb25zLnB1c2gobmV3IEFjdGlvbihuZXdTY29yZSwgdW5kZWZpbmVkLCBcIm1vZGlmeV9zY29yZVwiLCBuZXdTY29yZS5pZCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1Njb3JlO1xyXG59XHJcbiJdfQ==