"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateScoreActions = calculateScoreActions;

var _Score = require("./dataModels/Score");

var _Action = require("./dataModels/Action");

var _calculateScore = require("./calculateScore");

var _RepositoryLocalReactive = require("./repositories/RepositoryLocalReactive");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Calculates the score actions based on a list of actions
 */
async function calculateScoreActions({
  actions = [],
  repository = new _RepositoryLocalReactive.RepositoryLocalReactive(),
  calculator = _calculateScore.calculateScore
} = {}) {
  const scoreActions = [];
  const claimIdsToScore = [];
  const topScoreIds = [];
  await repository.notify(actions);

  for (const action of actions) {
    // find claims that may need scores changed
    if (action.type == 'add_claim' || action.type == 'modify_claim') {
      claimIdsToScore.push(action.dataId);
    } // //Add scores for new Score Tree
    // //action.oldData = the claim to start the new score tree from
    // //TODO: above is an unexpected use of oldData. See if this should be changed or documented as an exception
    // //action.newData = the base top score for the new score tree
    // //action.dataId = the new ID for the Score Tree
    // if (action.type == 'add_scoretree') {
    //     claimIdsToScore.push(action.oldData.id)
    //     const claim = await repository.getClaim(action.oldData.id);
    //     if (claim) {
    //         const newAction = new Action(action.newData, {}, "add_score", action.newData.id);
    //         scoreActions.push(newAction);
    //         repository.notify([newAction]);
    //     }
    // }


    if (action.type == "add_score") {
      const score = action.newData;
      claimIdsToScore.push(score.sourceClaimId);
    } //Add scores if edges adds new children to claims in score trees


    if (action.type == 'add_claimEdge' || action.type == 'modify_claimEdge') {
      const claimEdge = action.newData;
      claimIdsToScore.push(claimEdge.parentId);
    } //Walk up the scores for each claim to the top


    for (const claimId of claimIdsToScore) {
      const scoresForTheClaim = await repository.getScoresByClaimId(claimId);

      for (const claimScore of scoresForTheClaim) {
        // for each score, walk up the tree looking for the top (the first score to not have a parentId)
        let currentScore = claimScore;
        let topScoreId = claimScore.id;

        while ((_currentScore = currentScore) === null || _currentScore === void 0 ? void 0 : _currentScore.parentScoreId) {
          var _currentScore;

          topScoreId = currentScore.id;
          currentScore = await repository.getScore(currentScore.parentScoreId);
        }

        if (topScoreId) {
          topScoreIds.push(topScoreId);
        }
      }
    } //Re-calc all top scores with possible changed claims


    for (const topScoreId of topScoreIds) {
      const topScore = await repository.getScore(topScoreId);

      if (topScore) {
        await createBlankMissingScores(repository, topScoreId, topScore.sourceClaimId || "", scoreActions);
        await repository.notify(scoreActions);
        await calculateScoreTree(repository, topScore, calculator, scoreActions);
      }
    }
  }

  return scoreActions;
} //Create Blank Missing Scores


async function createBlankMissingScores(repository, currentScoreId, currentClaimId, actions) {
  const edges = await repository.getClaimEdgesByParentId(currentClaimId);
  const scores = await repository.getChildrenByScoreId(currentScoreId);

  for (const edge of edges) {
    //see if there is a matching child score for the child edge
    let score = scores.find(({
      sourceClaimId
    }) => sourceClaimId === edge.childId);

    if (!score) {
      //Create a new Score and attach it to it's parent
      score = new _Score.Score(edge.childId, currentScoreId, undefined, edge.pro, edge.affects);
      actions.push(new _Action.Action(score, undefined, "add_score", score.id));
    } //Recurse and through children


    await createBlankMissingScores(repository, score.id, edge.childId, actions);
  }
} //This function assume that all scores already exist


async function calculateScoreTree(repository, currentScore, calculator = _calculateScore.calculateScore, actions) {
  const oldScores = await repository.getChildrenByScoreId(currentScore.id);
  const newScores = [];

  for (const oldScore of oldScores) {
    //Calculate Children
    //TODO: remove any scores to calculate based on formulas
    newScores.push((await calculateScoreTree(repository, oldScore, calculator, actions)));
  }

  const newScoreFragment = calculator({
    childScores: newScores,
    reversible: currentScore.reversible
  }); //TODO: Modify the newScore based on any formulas
  //TODO: Should we add the new scores to the repository (If they are different form the old score?)

  const newScore = _objectSpread({}, currentScore, {}, newScoreFragment);

  if ((0, _Score.differentScores)(currentScore, newScore)) {
    actions.push(new _Action.Action(newScore, undefined, "add_score", newScore.id));
  }

  return newScore;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jYWxjdWxhdGVTY29yZUFjdGlvbnMudHMiXSwibmFtZXMiOlsiY2FsY3VsYXRlU2NvcmVBY3Rpb25zIiwiYWN0aW9ucyIsInJlcG9zaXRvcnkiLCJSZXBvc2l0b3J5TG9jYWxSZWFjdGl2ZSIsImNhbGN1bGF0b3IiLCJjYWxjdWxhdGVTY29yZSIsInNjb3JlQWN0aW9ucyIsImNsYWltSWRzVG9TY29yZSIsInRvcFNjb3JlSWRzIiwibm90aWZ5IiwiYWN0aW9uIiwidHlwZSIsInB1c2giLCJkYXRhSWQiLCJzY29yZSIsIm5ld0RhdGEiLCJzb3VyY2VDbGFpbUlkIiwiY2xhaW1FZGdlIiwicGFyZW50SWQiLCJjbGFpbUlkIiwic2NvcmVzRm9yVGhlQ2xhaW0iLCJnZXRTY29yZXNCeUNsYWltSWQiLCJjbGFpbVNjb3JlIiwiY3VycmVudFNjb3JlIiwidG9wU2NvcmVJZCIsImlkIiwicGFyZW50U2NvcmVJZCIsImdldFNjb3JlIiwidG9wU2NvcmUiLCJjcmVhdGVCbGFua01pc3NpbmdTY29yZXMiLCJjYWxjdWxhdGVTY29yZVRyZWUiLCJjdXJyZW50U2NvcmVJZCIsImN1cnJlbnRDbGFpbUlkIiwiZWRnZXMiLCJnZXRDbGFpbUVkZ2VzQnlQYXJlbnRJZCIsInNjb3JlcyIsImdldENoaWxkcmVuQnlTY29yZUlkIiwiZWRnZSIsImZpbmQiLCJjaGlsZElkIiwiU2NvcmUiLCJ1bmRlZmluZWQiLCJwcm8iLCJhZmZlY3RzIiwiQWN0aW9uIiwib2xkU2NvcmVzIiwibmV3U2NvcmVzIiwib2xkU2NvcmUiLCJuZXdTY29yZUZyYWdtZW50IiwiY2hpbGRTY29yZXMiLCJyZXZlcnNpYmxlIiwibmV3U2NvcmUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7QUFLQTs7Ozs7Ozs7QUFFQTs7O0FBR08sZUFBZUEscUJBQWYsQ0FBcUM7QUFBRUMsRUFBQUEsT0FBTyxHQUFHLEVBQVo7QUFBZ0JDLEVBQUFBLFVBQVUsR0FBRyxJQUFJQyxnREFB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RUFBa0M7QUFBRTtBQUNoQztBQUNBQyxJQUFBQSxTQUFTLENBQUNsQyxJQUFWLEVBQWUsTUFBTWtCLGtCQUFrQixDQUFDNUIsVUFBRCxFQUFhNkMsUUFBYixFQUF1QjNDLFVBQXZCLEVBQW1DSCxPQUFuQyxDQUF2QztBQUNIOztBQUVELFFBQU0rQyxnQkFBZ0IsR0FBRzVDLFVBQVUsQ0FBQztBQUNoQzZDLElBQUFBLFdBQVcsRUFBRUgsU0FEbUI7QUFFaENJLElBQUFBLFVBQVUsRUFBRTNCLFlBQVksQ0FBQzJCO0FBRk8sR0FBRCxDQUFuQyxDQVQ4SSxDQWE5STtBQUNBOztBQUNBLFFBQU1DLFFBQVEscUJBQVE1QixZQUFSLE1BQXlCeUIsZ0JBQXpCLENBQWQ7O0FBQ0EsTUFBSSw0QkFBZ0J6QixZQUFoQixFQUE4QjRCLFFBQTlCLENBQUosRUFBNkM7QUFDekNsRCxJQUFBQSxPQUFPLENBQUNXLElBQVIsQ0FBYSxJQUFJZ0MsY0FBSixDQUFXTyxRQUFYLEVBQXFCVixTQUFyQixFQUFnQyxXQUFoQyxFQUE2Q1UsUUFBUSxDQUFDMUIsRUFBdEQsQ0FBYjtBQUNIOztBQUNELFNBQU8wQixRQUFQO0FBQ0giLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTY29yZSwgZGlmZmVyZW50U2NvcmVzLCBpU2NvcmUgfSBmcm9tIFwiLi9kYXRhTW9kZWxzL1Njb3JlXCI7XHJcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gXCIuL2RhdGFNb2RlbHMvQWN0aW9uXCI7XHJcbmltcG9ydCB7IFJlcG9zaXRvcnlMb2NhbFB1cmUgfSBmcm9tIFwiLi9yZXBvc2l0b3JpZXMvUmVwb3NpdG9yeUxvY2FsUHVyZVwiO1xyXG5pbXBvcnQgeyBpQ2FsY3VsYXRlU2NvcmUsIGNhbGN1bGF0ZVNjb3JlIH0gZnJvbSBcIi4vY2FsY3VsYXRlU2NvcmVcIjtcclxuaW1wb3J0IHsgQ2xhaW0gfSBmcm9tIFwiLi9kYXRhTW9kZWxzL0NsYWltXCI7XHJcbmltcG9ydCB7IGlSZXBvc2l0b3J5IH0gZnJvbSBcIi4vZGF0YU1vZGVscy9pUmVwb3NpdG9yeVwiO1xyXG5pbXBvcnQgeyBDbGFpbUVkZ2UgfSBmcm9tIFwiLi9kYXRhTW9kZWxzL0NsYWltRWRnZVwiO1xyXG5pbXBvcnQgeyBuZXdJZCB9IGZyb20gXCIuL25ld0lkXCI7XHJcbmltcG9ydCB7IFJlcG9zaXRvcnlMb2NhbFJlYWN0aXZlIH0gZnJvbSBcIi4vcmVwb3NpdG9yaWVzL1JlcG9zaXRvcnlMb2NhbFJlYWN0aXZlXCI7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc2NvcmUgYWN0aW9ucyBiYXNlZCBvbiBhIGxpc3Qgb2YgYWN0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZVNjb3JlQWN0aW9ucyh7IGFjdGlvbnMgPSBbXSwgcmVwb3NpdG9yeSA9IG5ldyBSZXBvc2l0b3J5TG9jYWxSZWFjdGl2ZSgpLCBjYWxjdWxhdG9yID0gY2FsY3VsYXRlU2NvcmUgfToge1xyXG4gICAgLyoqIEFuIGFycmF5IG9mIGFjdGlvbnMsIHVzdWFsbHkgb24gY2xhaW1zIG9yIGVkZ2VzIHRoYXQgaW5jbHVzZSBubyBzY29yZXMqL1xyXG4gICAgYWN0aW9ucz86IEFjdGlvbltdO1xyXG4gICAgLyoqIFRoZSByZXBvc2l0b3J5IHVzZWQgdG8gZ2V0IGNvbnRleHQgZm9yIHRoZSBhY3Rpb25zICovXHJcbiAgICByZXBvc2l0b3J5PzogaVJlcG9zaXRvcnk7XHJcbiAgICAvKiogVGhlIGZ1bmN0aW9uIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBzY29yZXMgKi9cclxuICAgIGNhbGN1bGF0b3I/OiBpQ2FsY3VsYXRlU2NvcmU7XHJcbn0gPSB7fSxcclxuKSB7XHJcbiAgICBjb25zdCBzY29yZUFjdGlvbnM6IEFjdGlvbltdID0gW107XHJcbiAgICBjb25zdCBjbGFpbUlkc1RvU2NvcmU6IHN0cmluZ1tdID0gW107XHJcbiAgICBjb25zdCB0b3BTY29yZUlkczogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICBhd2FpdCByZXBvc2l0b3J5Lm5vdGlmeShhY3Rpb25zKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XHJcblxyXG4gICAgICAgIC8vIGZpbmQgY2xhaW1zIHRoYXQgbWF5IG5lZWQgc2NvcmVzIGNoYW5nZWRcclxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT0gJ2FkZF9jbGFpbScgfHwgYWN0aW9uLnR5cGUgPT0gJ21vZGlmeV9jbGFpbScpIHtcclxuICAgICAgICAgICAgY2xhaW1JZHNUb1Njb3JlLnB1c2goYWN0aW9uLmRhdGFJZClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIC8vQWRkIHNjb3JlcyBmb3IgbmV3IFNjb3JlIFRyZWVcclxuICAgICAgICAvLyAvL2FjdGlvbi5vbGREYXRhID0gdGhlIGNsYWltIHRvIHN0YXJ0IHRoZSBuZXcgc2NvcmUgdHJlZSBmcm9tXHJcbiAgICAgICAgLy8gLy9UT0RPOiBhYm92ZSBpcyBhbiB1bmV4cGVjdGVkIHVzZSBvZiBvbGREYXRhLiBTZWUgaWYgdGhpcyBzaG91bGQgYmUgY2hhbmdlZCBvciBkb2N1bWVudGVkIGFzIGFuIGV4Y2VwdGlvblxyXG4gICAgICAgIC8vIC8vYWN0aW9uLm5ld0RhdGEgPSB0aGUgYmFzZSB0b3Agc2NvcmUgZm9yIHRoZSBuZXcgc2NvcmUgdHJlZVxyXG4gICAgICAgIC8vIC8vYWN0aW9uLmRhdGFJZCA9IHRoZSBuZXcgSUQgZm9yIHRoZSBTY29yZSBUcmVlXHJcbiAgICAgICAgLy8gaWYgKGFjdGlvbi50eXBlID09ICdhZGRfc2NvcmV0cmVlJykge1xyXG4gICAgICAgIC8vICAgICBjbGFpbUlkc1RvU2NvcmUucHVzaChhY3Rpb24ub2xkRGF0YS5pZClcclxuICAgICAgICAvLyAgICAgY29uc3QgY2xhaW0gPSBhd2FpdCByZXBvc2l0b3J5LmdldENsYWltKGFjdGlvbi5vbGREYXRhLmlkKTtcclxuICAgICAgICAvLyAgICAgaWYgKGNsYWltKSB7XHJcbiAgICAgICAgLy8gICAgICAgICBjb25zdCBuZXdBY3Rpb24gPSBuZXcgQWN0aW9uKGFjdGlvbi5uZXdEYXRhLCB7fSwgXCJhZGRfc2NvcmVcIiwgYWN0aW9uLm5ld0RhdGEuaWQpO1xyXG4gICAgICAgIC8vICAgICAgICAgc2NvcmVBY3Rpb25zLnB1c2gobmV3QWN0aW9uKTtcclxuICAgICAgICAvLyAgICAgICAgIHJlcG9zaXRvcnkubm90aWZ5KFtuZXdBY3Rpb25dKTtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09IFwiYWRkX3Njb3JlXCIpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2NvcmUgPSBhY3Rpb24ubmV3RGF0YSBhcyBTY29yZTtcclxuICAgICAgICAgICAgY2xhaW1JZHNUb1Njb3JlLnB1c2goc2NvcmUuc291cmNlQ2xhaW1JZClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vQWRkIHNjb3JlcyBpZiBlZGdlcyBhZGRzIG5ldyBjaGlsZHJlbiB0byBjbGFpbXMgaW4gc2NvcmUgdHJlZXNcclxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT0gJ2FkZF9jbGFpbUVkZ2UnIHx8IGFjdGlvbi50eXBlID09ICdtb2RpZnlfY2xhaW1FZGdlJykge1xyXG4gICAgICAgICAgICBjb25zdCBjbGFpbUVkZ2UgPSBhY3Rpb24ubmV3RGF0YSBhcyBDbGFpbUVkZ2U7XHJcbiAgICAgICAgICAgIGNsYWltSWRzVG9TY29yZS5wdXNoKGNsYWltRWRnZS5wYXJlbnRJZClcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9XYWxrIHVwIHRoZSBzY29yZXMgZm9yIGVhY2ggY2xhaW0gdG8gdGhlIHRvcFxyXG4gICAgICAgIGZvciAoY29uc3QgY2xhaW1JZCBvZiBjbGFpbUlkc1RvU2NvcmUpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2NvcmVzRm9yVGhlQ2xhaW0gPSBhd2FpdCByZXBvc2l0b3J5LmdldFNjb3Jlc0J5Q2xhaW1JZChjbGFpbUlkKVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNsYWltU2NvcmUgb2Ygc2NvcmVzRm9yVGhlQ2xhaW0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIHNjb3JlLCB3YWxrIHVwIHRoZSB0cmVlIGxvb2tpbmcgZm9yIHRoZSB0b3AgKHRoZSBmaXJzdCBzY29yZSB0byBub3QgaGF2ZSBhIHBhcmVudElkKVxyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRTY29yZTogaVNjb3JlIHwgdW5kZWZpbmVkID0gY2xhaW1TY29yZTtcclxuICAgICAgICAgICAgICAgIGxldCB0b3BTY29yZUlkID0gY2xhaW1TY29yZS5pZDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50U2NvcmU/LnBhcmVudFNjb3JlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3BTY29yZUlkID0gY3VycmVudFNjb3JlLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IGF3YWl0IHJlcG9zaXRvcnkuZ2V0U2NvcmUoY3VycmVudFNjb3JlLnBhcmVudFNjb3JlSWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRvcFNjb3JlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3BTY29yZUlkcy5wdXNoKHRvcFNjb3JlSWQpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vUmUtY2FsYyBhbGwgdG9wIHNjb3JlcyB3aXRoIHBvc3NpYmxlIGNoYW5nZWQgY2xhaW1zXHJcbiAgICAgICAgZm9yIChjb25zdCB0b3BTY29yZUlkIG9mIHRvcFNjb3JlSWRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvcFNjb3JlID0gYXdhaXQgcmVwb3NpdG9yeS5nZXRTY29yZSh0b3BTY29yZUlkKVxyXG4gICAgICAgICAgICBpZiAodG9wU2NvcmUpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNyZWF0ZUJsYW5rTWlzc2luZ1Njb3JlcyhyZXBvc2l0b3J5LCB0b3BTY29yZUlkLCB0b3BTY29yZS5zb3VyY2VDbGFpbUlkIHx8IFwiXCIsIHNjb3JlQWN0aW9ucylcclxuICAgICAgICAgICAgICAgIGF3YWl0IHJlcG9zaXRvcnkubm90aWZ5KHNjb3JlQWN0aW9ucylcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNhbGN1bGF0ZVNjb3JlVHJlZShyZXBvc2l0b3J5LCB0b3BTY29yZSwgY2FsY3VsYXRvciwgc2NvcmVBY3Rpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2NvcmVBY3Rpb25zO1xyXG59XHJcblxyXG4vL0NyZWF0ZSBCbGFuayBNaXNzaW5nIFNjb3Jlc1xyXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVCbGFua01pc3NpbmdTY29yZXMocmVwb3NpdG9yeTogaVJlcG9zaXRvcnksIGN1cnJlbnRTY29yZUlkOiBzdHJpbmcsIGN1cnJlbnRDbGFpbUlkOiBzdHJpbmcsIGFjdGlvbnM6IEFjdGlvbltdKSB7XHJcbiAgICBjb25zdCBlZGdlcyA9IGF3YWl0IHJlcG9zaXRvcnkuZ2V0Q2xhaW1FZGdlc0J5UGFyZW50SWQoY3VycmVudENsYWltSWQpXHJcbiAgICBjb25zdCBzY29yZXMgPSBhd2FpdCByZXBvc2l0b3J5LmdldENoaWxkcmVuQnlTY29yZUlkKGN1cnJlbnRTY29yZUlkKVxyXG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XHJcbiAgICAgICAgLy9zZWUgaWYgdGhlcmUgaXMgYSBtYXRjaGluZyBjaGlsZCBzY29yZSBmb3IgdGhlIGNoaWxkIGVkZ2VcclxuICAgICAgICBsZXQgc2NvcmUgPSBzY29yZXMuZmluZCgoeyBzb3VyY2VDbGFpbUlkIH0pID0+IHNvdXJjZUNsYWltSWQgPT09IGVkZ2UuY2hpbGRJZCk7XHJcbiAgICAgICAgaWYgKCFzY29yZSkge1xyXG4gICAgICAgICAgICAvL0NyZWF0ZSBhIG5ldyBTY29yZSBhbmQgYXR0YWNoIGl0IHRvIGl0J3MgcGFyZW50XHJcbiAgICAgICAgICAgIHNjb3JlID0gbmV3IFNjb3JlKGVkZ2UuY2hpbGRJZCwgY3VycmVudFNjb3JlSWQsIHVuZGVmaW5lZCwgZWRnZS5wcm8sIGVkZ2UuYWZmZWN0cyk7XHJcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChuZXcgQWN0aW9uKHNjb3JlLCB1bmRlZmluZWQsIFwiYWRkX3Njb3JlXCIsIHNjb3JlLmlkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vUmVjdXJzZSBhbmQgdGhyb3VnaCBjaGlsZHJlblxyXG4gICAgICAgIGF3YWl0IGNyZWF0ZUJsYW5rTWlzc2luZ1Njb3JlcyhyZXBvc2l0b3J5LCBzY29yZS5pZCwgZWRnZS5jaGlsZElkLCBhY3Rpb25zKTtcclxuICAgIH1cclxufVxyXG5cclxuLy9UaGlzIGZ1bmN0aW9uIGFzc3VtZSB0aGF0IGFsbCBzY29yZXMgYWxyZWFkeSBleGlzdFxyXG5hc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVTY29yZVRyZWUocmVwb3NpdG9yeTogaVJlcG9zaXRvcnksIGN1cnJlbnRTY29yZTogaVNjb3JlLCBjYWxjdWxhdG9yOiBpQ2FsY3VsYXRlU2NvcmUgPSBjYWxjdWxhdGVTY29yZSwgYWN0aW9uczogQWN0aW9uW10pIHtcclxuICAgIGNvbnN0IG9sZFNjb3JlcyA9IGF3YWl0IHJlcG9zaXRvcnkuZ2V0Q2hpbGRyZW5CeVNjb3JlSWQoY3VycmVudFNjb3JlLmlkKVxyXG4gICAgY29uc3QgbmV3U2NvcmVzOiBpU2NvcmVbXSA9IFtdO1xyXG5cclxuICAgIGZvciAoY29uc3Qgb2xkU2NvcmUgb2Ygb2xkU2NvcmVzKSB7IC8vQ2FsY3VsYXRlIENoaWxkcmVuXHJcbiAgICAgICAgLy9UT0RPOiByZW1vdmUgYW55IHNjb3JlcyB0byBjYWxjdWxhdGUgYmFzZWQgb24gZm9ybXVsYXNcclxuICAgICAgICBuZXdTY29yZXMucHVzaChhd2FpdCBjYWxjdWxhdGVTY29yZVRyZWUocmVwb3NpdG9yeSwgb2xkU2NvcmUsIGNhbGN1bGF0b3IsIGFjdGlvbnMpKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuZXdTY29yZUZyYWdtZW50ID0gY2FsY3VsYXRvcih7XHJcbiAgICAgICAgY2hpbGRTY29yZXM6IG5ld1Njb3JlcyxcclxuICAgICAgICByZXZlcnNpYmxlOiBjdXJyZW50U2NvcmUucmV2ZXJzaWJsZSxcclxuICAgIH0pXHJcbiAgICAvL1RPRE86IE1vZGlmeSB0aGUgbmV3U2NvcmUgYmFzZWQgb24gYW55IGZvcm11bGFzXHJcbiAgICAvL1RPRE86IFNob3VsZCB3ZSBhZGQgdGhlIG5ldyBzY29yZXMgdG8gdGhlIHJlcG9zaXRvcnkgKElmIHRoZXkgYXJlIGRpZmZlcmVudCBmb3JtIHRoZSBvbGQgc2NvcmU/KVxyXG4gICAgY29uc3QgbmV3U2NvcmUgPSB7IC4uLmN1cnJlbnRTY29yZSwgLi4ubmV3U2NvcmVGcmFnbWVudCB9XHJcbiAgICBpZiAoZGlmZmVyZW50U2NvcmVzKGN1cnJlbnRTY29yZSwgbmV3U2NvcmUpKSB7XHJcbiAgICAgICAgYWN0aW9ucy5wdXNoKG5ldyBBY3Rpb24obmV3U2NvcmUsIHVuZGVmaW5lZCwgXCJhZGRfc2NvcmVcIiwgbmV3U2NvcmUuaWQpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdTY29yZTtcclxufVxyXG4iXX0=