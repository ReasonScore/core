"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateScoreActions = calculateScoreActions;

var _Score = require("./dataModels/Score");

var _Action = require("./dataModels/Action");

var _calculateScore = require("./calculateScore");

var _RepositoryLocalReactive = require("./repositories/RepositoryLocalReactive");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Calculates the score actions based on a list of actions
 */
async function calculateScoreActions({
  actions = [],
  repository = new _RepositoryLocalReactive.RepositoryLocalReactive(),
  calculator = _calculateScore.calculateScore
} = {}) {
  const scoreActions = [];
  const claimIdsToScore = [];
  const topScoreIds = [];
  await repository.notify(actions);

  for (const action of actions) {
    // find claims that may need scores changed
    if (action.type == 'add_claim' || action.type == 'modify_claim') {
      claimIdsToScore.push(action.dataId);
    }

    if (action.type == "add_score") {
      let score = action.newData;

      if (!score.parentId) {
        const scoreTemp = await repository.getScore(action.dataId);

        if (scoreTemp) {
          score = scoreTemp;
        }
      }

      claimIdsToScore.push(score.sourceClaimId);
    } //Add scores if edges adds new children to claims in score trees


    if (action.type == 'add_claimEdge' || action.type == 'modify_claimEdge') {
      let claimEdge = action.newData;

      if (!claimEdge.parentId) {
        const claimEdgeTemp = await repository.getClaimEdge(action.dataId);

        if (claimEdgeTemp) {
          claimEdge = claimEdgeTemp;
        }
      }

      claimIdsToScore.push(claimEdge.parentId);
    } //TODO: If an edge changes then modify the existing scores to match


    if (action.type == 'modify_claimEdge') {
      let claimEdge = await repository.getClaimEdge(action.dataId);
      claimEdge = _objectSpread({}, claimEdge, {}, action.newData);

      if (claimEdge) {
        action.newData;
        const scores = await repository.getScoresBySourceId(claimEdge.id);

        for (const score of scores) {
          //TODO: Where should I put this? It is modifying am object. If it is reactive i should just change the data. If pure it should be a new object.
          //For now I will modify it but it may not trigger updates in a pure library (React)
          //This change should also probably be centralized somewhere to reduce the chance of inconsistent bugs. I think it will happen in multiple paces
          //Nope, it is an action so it should always be a new object. If it goes into a reactive respoitory then it will modify the actual object
          //Should I group these actions or just throw them in one at a time like I am doing
          if (score.pro != claimEdge.pro || score.affects != claimEdge.affects) {
            const action = new _Action.Action({
              pro: claimEdge.pro,
              affects: claimEdge.affects
            }, score, "modify_score", score.id);
            scoreActions.push(action);
            await repository.notify([action]);
          }
        }
      }
    }
  } //Walk up the scores for each claim to the top


  for (const claimId of claimIdsToScore) {
    const scoresForTheClaim = await repository.getScoresBySourceId(claimId);

    for (const claimScore of scoresForTheClaim) {
      // for each score, walk up the tree looking for the top (the first score to not have a parentId)
      let currentScore = claimScore;
      let topScoreId = claimScore.id;

      do {
        var _currentScore;

        if (currentScore.parentScoreId) {
          currentScore = await repository.getScore(currentScore.parentScoreId);
        }

        if (currentScore) {
          topScoreId = currentScore.id;
        }
      } while ((_currentScore = currentScore) === null || _currentScore === void 0 ? void 0 : _currentScore.parentScoreId);

      if (topScoreId && topScoreIds.indexOf(topScoreId) == -1) {
        topScoreIds.push(topScoreId);
      }
    }
  } //Re-calc all top scores with possible changed claims


  for (const topScoreId of topScoreIds) {
    const topScore = await repository.getScore(topScoreId);

    if (topScore) {
      const tempMissingScoreActions = [];
      await createBlankMissingScores(repository, topScoreId, topScore.sourceClaimId || "", tempMissingScoreActions, topScoreId);

      if (tempMissingScoreActions.length > 0) {
        await repository.notify(tempMissingScoreActions);
      }

      const tempcalculateScoreTreeActions = [];
      await calculateScoreTree(repository, topScore, calculator, tempMissingScoreActions);
      scoreActions.push(...tempMissingScoreActions, ...tempcalculateScoreTreeActions);
    }
  } //TODO: Review this decision: Feed the score actions back into the repository so this repository is up to date in case it is used 


  await repository.notify(scoreActions);
  return scoreActions;
} //Create Blank Missing Scores


async function createBlankMissingScores(repository, currentScoreId, currentClaimId, actions, topScoreId) {
  const edges = await repository.getClaimEdgesByParentId(currentClaimId);
  const scores = await repository.getChildrenByScoreId(currentScoreId);

  for (const edge of edges) {
    //see if there is a matching child score for the child edge
    let score = scores.find(({
      sourceClaimId
    }) => sourceClaimId === edge.childId);

    if (!score) {
      //Create a new Score and attach it to it's parent
      score = new _Score.Score(edge.childId, topScoreId, currentScoreId, edge.id, undefined, edge.pro, edge.affects);
      actions.push(new _Action.Action(score, undefined, "add_score", score.id));
    } //Recurse and through children


    await createBlankMissingScores(repository, score.id, edge.childId, actions, topScoreId);
  }
} //This function assume that all scores already exist


async function calculateScoreTree(repository, currentScore, calculator = _calculateScore.calculateScore, actions) {
  const oldScores = await repository.getChildrenByScoreId(currentScore.id);
  const newScores = [];

  for (const oldScore of oldScores) {
    //Calculate Children
    //TODO: remove any scores to calculate based on formulas that exclude scores
    newScores.push((await calculateScoreTree(repository, oldScore, calculator, actions)));
  }

  const newScoreFragment = calculator({
    childScores: newScores,
    reversible: currentScore.reversible
  }); //TODO: Modify the newScore based on any formulas

  const newScore = _objectSpread({}, currentScore, {}, newScoreFragment);

  if ((0, _Score.differentScores)(currentScore, newScore)) {
    actions.push(new _Action.Action(newScore, undefined, "modify_score", newScore.id));
  }

  return newScore;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jYWxjdWxhdGVTY29yZUFjdGlvbnMudHMiXSwibmFtZXMiOlsiY2FsY3VsYXRlU2NvcmVBY3Rpb25zIiwiYWN0aW9ucyIsInJlcG9zaXRvcnkiLCJSZXBvc2l0b3J5TG9jYWxSZWFjdGl2ZSIsImNhbGN1bGF0b3IiLCJjYWxjdWxhdGVTY29yZSIsInNjb3JlQWN0aW9ucyIsImNsYWltSWRzVG9TY29yZSIsInRvcFNjb3JlSWRzIiwibm90aWZ5IiwiYWN0aW9uIiwidHlwZSIsInB1c2giLCJkYXRhSWQiLCJzY29yZSIsIm5ld0RhdGEiLCJwYXJlbnRJZCIsInNjb3JlVGVtcCIsImdldFNjb3JlIiwic291cmNlQ2xhaW1JZCIsImNsYWltRWRnZSIsImNsYWltRWRnZVRlbXAiLCJnZXRDbGFpbUVkZ2UiLCJzY29yZXMiLCJnZXRTY29yZXNCeVNvdXJjZUlkIiwiaWQiLCJwcm8iLCJhZmZlY3RzIiwiQWN0aW9uIiwiY2xhaW1JZCIsInNjb3Jlc0ZvclRoZUNsYWltIiwiY2xhaW1TY29yZSIsImN1cnJlbnRTY29yZSIsInRvcFNjb3JlSWQiLCJwYXJlbnRTY29yZUlkIiwiaW5kZXhPZiIsInRvcFNjb3JlIiwidGVtcE1pc3NpbmdTY29yZUFjdGlvbnMiLCJjcmVhdGVCbGFua01pc3NpbmdTY29yZXMiLCJsZW5ndGgiLCJ0ZW1wY2FsY3VsYXRlU2NvcmVUcmVlQWN0aW9ucyIsImNhbGN1bGF0ZVNjb3JlVHJlZSIsImN1cnJlbnRTY29yZUlkIiwiY3VycmVudENsYWltSWQiLCJlZGdlcyIsImdldENsYWltRWRnZXNCeVBhcmVudElkIiwiZ2V0Q2hpbGRyZW5CeVNjb3JlSWQiLCJlZGdlIiwiZmluZCIsImNoaWxkSWQiLCJTY29yZSIsInVuZGVmaW5lZCIsIm9sZFNjb3JlcyIsIm5ld1Njb3JlcyIsIm9sZFNjb3JlIiwibmV3U2NvcmVGcmFnbWVudCIsImNoaWxkU2NvcmVzIiwicmV2ZXJzaWJsZSIsIm5ld1Njb3JlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7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QUNoQ29ELElBQUFBLFdBQVcsRUFBRUgsU0FEbUI7QUFFaENJLElBQUFBLFVBQVUsRUFBRXpCLFlBQVksQ0FBQ3lCO0FBRk8sR0FBRCxDQUFuQyxDQVQ4SSxDQWM5STs7QUFDQSxRQUFNQyxRQUFRLHFCQUFRMUIsWUFBUixNQUF5QnVCLGdCQUF6QixDQUFkOztBQUNBLE1BQUksNEJBQWdCdkIsWUFBaEIsRUFBOEIwQixRQUE5QixDQUFKLEVBQTZDO0FBQ3pDekQsSUFBQUEsT0FBTyxDQUFDVyxJQUFSLENBQWEsSUFBSWdCLGNBQUosQ0FBVzhCLFFBQVgsRUFBcUJQLFNBQXJCLEVBQWdDLGNBQWhDLEVBQWdETyxRQUFRLENBQUNqQyxFQUF6RCxDQUFiO0FBQ0g7O0FBQ0QsU0FBT2lDLFFBQVA7QUFDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNjb3JlLCBkaWZmZXJlbnRTY29yZXMsIGlTY29yZSB9IGZyb20gXCIuL2RhdGFNb2RlbHMvU2NvcmVcIjtcclxuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSBcIi4vZGF0YU1vZGVscy9BY3Rpb25cIjtcclxuaW1wb3J0IHsgUmVwb3NpdG9yeUxvY2FsUHVyZSB9IGZyb20gXCIuL3JlcG9zaXRvcmllcy9SZXBvc2l0b3J5TG9jYWxQdXJlXCI7XHJcbmltcG9ydCB7IGlDYWxjdWxhdGVTY29yZSwgY2FsY3VsYXRlU2NvcmUgfSBmcm9tIFwiLi9jYWxjdWxhdGVTY29yZVwiO1xyXG5pbXBvcnQgeyBDbGFpbSB9IGZyb20gXCIuL2RhdGFNb2RlbHMvQ2xhaW1cIjtcclxuaW1wb3J0IHsgaVJlcG9zaXRvcnkgfSBmcm9tIFwiLi9kYXRhTW9kZWxzL2lSZXBvc2l0b3J5XCI7XHJcbmltcG9ydCB7IENsYWltRWRnZSwgaUNsYWltRWRnZSB9IGZyb20gXCIuL2RhdGFNb2RlbHMvQ2xhaW1FZGdlXCI7XHJcbmltcG9ydCB7IG5ld0lkIH0gZnJvbSBcIi4vbmV3SWRcIjtcclxuaW1wb3J0IHsgUmVwb3NpdG9yeUxvY2FsUmVhY3RpdmUgfSBmcm9tIFwiLi9yZXBvc2l0b3JpZXMvUmVwb3NpdG9yeUxvY2FsUmVhY3RpdmVcIjtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzY29yZSBhY3Rpb25zIGJhc2VkIG9uIGEgbGlzdCBvZiBhY3Rpb25zXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlU2NvcmVBY3Rpb25zKHsgYWN0aW9ucyA9IFtdLCByZXBvc2l0b3J5ID0gbmV3IFJlcG9zaXRvcnlMb2NhbFJlYWN0aXZlKCksIGNhbGN1bGF0b3IgPSBjYWxjdWxhdGVTY29yZSB9OiB7XHJcbiAgICAvKiogQW4gYXJyYXkgb2YgYWN0aW9ucywgdXN1YWxseSBvbiBjbGFpbXMgb3IgZWRnZXMgdGhhdCBpbmNsdXNlIG5vIHNjb3JlcyovXHJcbiAgICBhY3Rpb25zPzogQWN0aW9uW107XHJcbiAgICAvKiogVGhlIHJlcG9zaXRvcnkgdXNlZCB0byBnZXQgY29udGV4dCBmb3IgdGhlIGFjdGlvbnMgKi9cclxuICAgIHJlcG9zaXRvcnk/OiBpUmVwb3NpdG9yeTtcclxuICAgIC8qKiBUaGUgZnVuY3Rpb24gdXNlZCB0byBjYWxjdWxhdGUgdGhlIHNjb3JlcyAqL1xyXG4gICAgY2FsY3VsYXRvcj86IGlDYWxjdWxhdGVTY29yZTtcclxufSA9IHt9LFxyXG4pIHtcclxuICAgIGNvbnN0IHNjb3JlQWN0aW9uczogQWN0aW9uW10gPSBbXTtcclxuICAgIGNvbnN0IGNsYWltSWRzVG9TY29yZTogc3RyaW5nW10gPSBbXTtcclxuICAgIGNvbnN0IHRvcFNjb3JlSWRzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgIGF3YWl0IHJlcG9zaXRvcnkubm90aWZ5KGFjdGlvbnMpO1xyXG4gICAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xyXG5cclxuICAgICAgICAvLyBmaW5kIGNsYWltcyB0aGF0IG1heSBuZWVkIHNjb3JlcyBjaGFuZ2VkXHJcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09ICdhZGRfY2xhaW0nIHx8IGFjdGlvbi50eXBlID09ICdtb2RpZnlfY2xhaW0nKSB7XHJcbiAgICAgICAgICAgIGNsYWltSWRzVG9TY29yZS5wdXNoKGFjdGlvbi5kYXRhSWQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT0gXCJhZGRfc2NvcmVcIikge1xyXG4gICAgICAgICAgICBsZXQgc2NvcmUgPSBhY3Rpb24ubmV3RGF0YSBhcyBpU2NvcmU7XHJcbiAgICAgICAgICAgIGlmICghc2NvcmUucGFyZW50SWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjb3JlVGVtcCA9IGF3YWl0IHJlcG9zaXRvcnkuZ2V0U2NvcmUoYWN0aW9uLmRhdGFJZClcclxuICAgICAgICAgICAgICAgIGlmIChzY29yZVRlbXApIHtcclxuICAgICAgICAgICAgICAgICAgICBzY29yZSA9IHNjb3JlVGVtcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2xhaW1JZHNUb1Njb3JlLnB1c2goc2NvcmUuc291cmNlQ2xhaW1JZClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vQWRkIHNjb3JlcyBpZiBlZGdlcyBhZGRzIG5ldyBjaGlsZHJlbiB0byBjbGFpbXMgaW4gc2NvcmUgdHJlZXNcclxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT0gJ2FkZF9jbGFpbUVkZ2UnIHx8IGFjdGlvbi50eXBlID09ICdtb2RpZnlfY2xhaW1FZGdlJykge1xyXG4gICAgICAgICAgICBsZXQgY2xhaW1FZGdlID0gYWN0aW9uLm5ld0RhdGEgYXMgaUNsYWltRWRnZTtcclxuICAgICAgICAgICAgaWYgKCFjbGFpbUVkZ2UucGFyZW50SWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsYWltRWRnZVRlbXAgPSBhd2FpdCByZXBvc2l0b3J5LmdldENsYWltRWRnZShhY3Rpb24uZGF0YUlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKGNsYWltRWRnZVRlbXApIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGFpbUVkZ2UgPSBjbGFpbUVkZ2VUZW1wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNsYWltSWRzVG9TY29yZS5wdXNoKGNsYWltRWRnZS5wYXJlbnRJZClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETzogSWYgYW4gZWRnZSBjaGFuZ2VzIHRoZW4gbW9kaWZ5IHRoZSBleGlzdGluZyBzY29yZXMgdG8gbWF0Y2hcclxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT0gJ21vZGlmeV9jbGFpbUVkZ2UnKSB7XHJcbiAgICAgICAgICAgIGxldCBjbGFpbUVkZ2UgPSBhd2FpdCByZXBvc2l0b3J5LmdldENsYWltRWRnZShhY3Rpb24uZGF0YUlkKVxyXG4gICAgICAgICAgICBjbGFpbUVkZ2UgPSB7IC4uLmNsYWltRWRnZSwgLi4uYWN0aW9uLm5ld0RhdGEgfVxyXG4gICAgICAgICAgICBpZiAoY2xhaW1FZGdlKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb24ubmV3RGF0YSBhcyBDbGFpbUVkZ2U7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY29yZXMgPSBhd2FpdCByZXBvc2l0b3J5LmdldFNjb3Jlc0J5U291cmNlSWQoY2xhaW1FZGdlLmlkKVxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzY29yZSBvZiBzY29yZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE86IFdoZXJlIHNob3VsZCBJIHB1dCB0aGlzPyBJdCBpcyBtb2RpZnlpbmcgYW0gb2JqZWN0LiBJZiBpdCBpcyByZWFjdGl2ZSBpIHNob3VsZCBqdXN0IGNoYW5nZSB0aGUgZGF0YS4gSWYgcHVyZSBpdCBzaG91bGQgYmUgYSBuZXcgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vRm9yIG5vdyBJIHdpbGwgbW9kaWZ5IGl0IGJ1dCBpdCBtYXkgbm90IHRyaWdnZXIgdXBkYXRlcyBpbiBhIHB1cmUgbGlicmFyeSAoUmVhY3QpXHJcbiAgICAgICAgICAgICAgICAgICAgLy9UaGlzIGNoYW5nZSBzaG91bGQgYWxzbyBwcm9iYWJseSBiZSBjZW50cmFsaXplZCBzb21ld2hlcmUgdG8gcmVkdWNlIHRoZSBjaGFuY2Ugb2YgaW5jb25zaXN0ZW50IGJ1Z3MuIEkgdGhpbmsgaXQgd2lsbCBoYXBwZW4gaW4gbXVsdGlwbGUgcGFjZXNcclxuICAgICAgICAgICAgICAgICAgICAvL05vcGUsIGl0IGlzIGFuIGFjdGlvbiBzbyBpdCBzaG91bGQgYWx3YXlzIGJlIGEgbmV3IG9iamVjdC4gSWYgaXQgZ29lcyBpbnRvIGEgcmVhY3RpdmUgcmVzcG9pdG9yeSB0aGVuIGl0IHdpbGwgbW9kaWZ5IHRoZSBhY3R1YWwgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgLy9TaG91bGQgSSBncm91cCB0aGVzZSBhY3Rpb25zIG9yIGp1c3QgdGhyb3cgdGhlbSBpbiBvbmUgYXQgYSB0aW1lIGxpa2UgSSBhbSBkb2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29yZS5wcm8gIT0gY2xhaW1FZGdlLnBybyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29yZS5hZmZlY3RzICE9IGNsYWltRWRnZS5hZmZlY3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IG5ldyBBY3Rpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvOiBjbGFpbUVkZ2UucHJvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0czogY2xhaW1FZGdlLmFmZmVjdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHNjb3JlLCBcIm1vZGlmeV9zY29yZVwiLCBzY29yZS5pZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmVBY3Rpb25zLnB1c2goYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVwb3NpdG9yeS5ub3RpZnkoW2FjdGlvbl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1dhbGsgdXAgdGhlIHNjb3JlcyBmb3IgZWFjaCBjbGFpbSB0byB0aGUgdG9wXHJcbiAgICBmb3IgKGNvbnN0IGNsYWltSWQgb2YgY2xhaW1JZHNUb1Njb3JlKSB7XHJcbiAgICAgICAgY29uc3Qgc2NvcmVzRm9yVGhlQ2xhaW0gPSBhd2FpdCByZXBvc2l0b3J5LmdldFNjb3Jlc0J5U291cmNlSWQoY2xhaW1JZClcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBjbGFpbVNjb3JlIG9mIHNjb3Jlc0ZvclRoZUNsYWltKSB7XHJcbiAgICAgICAgICAgIC8vIGZvciBlYWNoIHNjb3JlLCB3YWxrIHVwIHRoZSB0cmVlIGxvb2tpbmcgZm9yIHRoZSB0b3AgKHRoZSBmaXJzdCBzY29yZSB0byBub3QgaGF2ZSBhIHBhcmVudElkKVxyXG4gICAgICAgICAgICBsZXQgY3VycmVudFNjb3JlOiBpU2NvcmUgfCB1bmRlZmluZWQgPSBjbGFpbVNjb3JlO1xyXG4gICAgICAgICAgICBsZXQgdG9wU2NvcmVJZCA9IGNsYWltU2NvcmUuaWQ7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2NvcmUucGFyZW50U2NvcmVJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IGF3YWl0IHJlcG9zaXRvcnkuZ2V0U2NvcmUoY3VycmVudFNjb3JlLnBhcmVudFNjb3JlSWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29yZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcFNjb3JlSWQgPSBjdXJyZW50U2NvcmUuaWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnJlbnRTY29yZT8ucGFyZW50U2NvcmVJZClcclxuXHJcbiAgICAgICAgICAgIGlmICh0b3BTY29yZUlkICYmIHRvcFNjb3JlSWRzLmluZGV4T2YodG9wU2NvcmVJZCkgPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRvcFNjb3JlSWRzLnB1c2godG9wU2NvcmVJZClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1JlLWNhbGMgYWxsIHRvcCBzY29yZXMgd2l0aCBwb3NzaWJsZSBjaGFuZ2VkIGNsYWltc1xyXG4gICAgZm9yIChjb25zdCB0b3BTY29yZUlkIG9mIHRvcFNjb3JlSWRzKSB7XHJcbiAgICAgICAgY29uc3QgdG9wU2NvcmUgPSBhd2FpdCByZXBvc2l0b3J5LmdldFNjb3JlKHRvcFNjb3JlSWQpXHJcbiAgICAgICAgaWYgKHRvcFNjb3JlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbXBNaXNzaW5nU2NvcmVBY3Rpb25zOiBBY3Rpb25bXSA9IFtdO1xyXG4gICAgICAgICAgICBhd2FpdCBjcmVhdGVCbGFua01pc3NpbmdTY29yZXMocmVwb3NpdG9yeSwgdG9wU2NvcmVJZCwgdG9wU2NvcmUuc291cmNlQ2xhaW1JZCB8fCBcIlwiLCB0ZW1wTWlzc2luZ1Njb3JlQWN0aW9ucywgdG9wU2NvcmVJZClcclxuICAgICAgICAgICAgaWYgKHRlbXBNaXNzaW5nU2NvcmVBY3Rpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHJlcG9zaXRvcnkubm90aWZ5KHRlbXBNaXNzaW5nU2NvcmVBY3Rpb25zKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbXBjYWxjdWxhdGVTY29yZVRyZWVBY3Rpb25zOiBBY3Rpb25bXSA9IFtdO1xyXG4gICAgICAgICAgICBhd2FpdCBjYWxjdWxhdGVTY29yZVRyZWUocmVwb3NpdG9yeSwgdG9wU2NvcmUsIGNhbGN1bGF0b3IsIHRlbXBNaXNzaW5nU2NvcmVBY3Rpb25zKTtcclxuICAgICAgICAgICAgc2NvcmVBY3Rpb25zLnB1c2goLi4udGVtcE1pc3NpbmdTY29yZUFjdGlvbnMsIC4uLnRlbXBjYWxjdWxhdGVTY29yZVRyZWVBY3Rpb25zKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL1RPRE86IFJldmlldyB0aGlzIGRlY2lzaW9uOiBGZWVkIHRoZSBzY29yZSBhY3Rpb25zIGJhY2sgaW50byB0aGUgcmVwb3NpdG9yeSBzbyB0aGlzIHJlcG9zaXRvcnkgaXMgdXAgdG8gZGF0ZSBpbiBjYXNlIGl0IGlzIHVzZWQgXHJcbiAgICBhd2FpdCByZXBvc2l0b3J5Lm5vdGlmeShzY29yZUFjdGlvbnMpO1xyXG5cclxuICAgIHJldHVybiBzY29yZUFjdGlvbnM7XHJcbn1cclxuXHJcbi8vQ3JlYXRlIEJsYW5rIE1pc3NpbmcgU2NvcmVzXHJcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUJsYW5rTWlzc2luZ1Njb3JlcyhyZXBvc2l0b3J5OiBpUmVwb3NpdG9yeSwgY3VycmVudFNjb3JlSWQ6IHN0cmluZywgY3VycmVudENsYWltSWQ6IHN0cmluZywgYWN0aW9uczogQWN0aW9uW10sIHRvcFNjb3JlSWQ6IHN0cmluZykge1xyXG4gICAgY29uc3QgZWRnZXMgPSBhd2FpdCByZXBvc2l0b3J5LmdldENsYWltRWRnZXNCeVBhcmVudElkKGN1cnJlbnRDbGFpbUlkKVxyXG4gICAgY29uc3Qgc2NvcmVzID0gYXdhaXQgcmVwb3NpdG9yeS5nZXRDaGlsZHJlbkJ5U2NvcmVJZChjdXJyZW50U2NvcmVJZClcclxuICAgIGZvciAoY29uc3QgZWRnZSBvZiBlZGdlcykge1xyXG4gICAgICAgIC8vc2VlIGlmIHRoZXJlIGlzIGEgbWF0Y2hpbmcgY2hpbGQgc2NvcmUgZm9yIHRoZSBjaGlsZCBlZGdlXHJcbiAgICAgICAgbGV0IHNjb3JlID0gc2NvcmVzLmZpbmQoKHsgc291cmNlQ2xhaW1JZCB9KSA9PiBzb3VyY2VDbGFpbUlkID09PSBlZGdlLmNoaWxkSWQpO1xyXG4gICAgICAgIGlmICghc2NvcmUpIHtcclxuICAgICAgICAgICAgLy9DcmVhdGUgYSBuZXcgU2NvcmUgYW5kIGF0dGFjaCBpdCB0byBpdCdzIHBhcmVudFxyXG4gICAgICAgICAgICBzY29yZSA9IG5ldyBTY29yZShlZGdlLmNoaWxkSWQsIHRvcFNjb3JlSWQsIGN1cnJlbnRTY29yZUlkLCBlZGdlLmlkLCB1bmRlZmluZWQsIGVkZ2UucHJvLCBlZGdlLmFmZmVjdHMpO1xyXG4gICAgICAgICAgICBhY3Rpb25zLnB1c2gobmV3IEFjdGlvbihzY29yZSwgdW5kZWZpbmVkLCBcImFkZF9zY29yZVwiLCBzY29yZS5pZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL1JlY3Vyc2UgYW5kIHRocm91Z2ggY2hpbGRyZW5cclxuICAgICAgICBhd2FpdCBjcmVhdGVCbGFua01pc3NpbmdTY29yZXMocmVwb3NpdG9yeSwgc2NvcmUuaWQsIGVkZ2UuY2hpbGRJZCwgYWN0aW9ucywgdG9wU2NvcmVJZCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vVGhpcyBmdW5jdGlvbiBhc3N1bWUgdGhhdCBhbGwgc2NvcmVzIGFscmVhZHkgZXhpc3RcclxuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlU2NvcmVUcmVlKHJlcG9zaXRvcnk6IGlSZXBvc2l0b3J5LCBjdXJyZW50U2NvcmU6IGlTY29yZSwgY2FsY3VsYXRvcjogaUNhbGN1bGF0ZVNjb3JlID0gY2FsY3VsYXRlU2NvcmUsIGFjdGlvbnM6IEFjdGlvbltdKSB7XHJcbiAgICBjb25zdCBvbGRTY29yZXMgPSBhd2FpdCByZXBvc2l0b3J5LmdldENoaWxkcmVuQnlTY29yZUlkKGN1cnJlbnRTY29yZS5pZClcclxuICAgIGNvbnN0IG5ld1Njb3JlczogaVNjb3JlW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG9sZFNjb3JlIG9mIG9sZFNjb3JlcykgeyAvL0NhbGN1bGF0ZSBDaGlsZHJlblxyXG4gICAgICAgIC8vVE9ETzogcmVtb3ZlIGFueSBzY29yZXMgdG8gY2FsY3VsYXRlIGJhc2VkIG9uIGZvcm11bGFzIHRoYXQgZXhjbHVkZSBzY29yZXNcclxuICAgICAgICBuZXdTY29yZXMucHVzaChhd2FpdCBjYWxjdWxhdGVTY29yZVRyZWUocmVwb3NpdG9yeSwgb2xkU2NvcmUsIGNhbGN1bGF0b3IsIGFjdGlvbnMpKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuZXdTY29yZUZyYWdtZW50ID0gY2FsY3VsYXRvcih7XHJcbiAgICAgICAgY2hpbGRTY29yZXM6IG5ld1Njb3JlcyxcclxuICAgICAgICByZXZlcnNpYmxlOiBjdXJyZW50U2NvcmUucmV2ZXJzaWJsZSxcclxuICAgIH0pXHJcblxyXG4gICAgLy9UT0RPOiBNb2RpZnkgdGhlIG5ld1Njb3JlIGJhc2VkIG9uIGFueSBmb3JtdWxhc1xyXG4gICAgY29uc3QgbmV3U2NvcmUgPSB7IC4uLmN1cnJlbnRTY29yZSwgLi4ubmV3U2NvcmVGcmFnbWVudCB9XHJcbiAgICBpZiAoZGlmZmVyZW50U2NvcmVzKGN1cnJlbnRTY29yZSwgbmV3U2NvcmUpKSB7XHJcbiAgICAgICAgYWN0aW9ucy5wdXNoKG5ldyBBY3Rpb24obmV3U2NvcmUsIHVuZGVmaW5lZCwgXCJtb2RpZnlfc2NvcmVcIiwgbmV3U2NvcmUuaWQpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdTY29yZTtcclxufVxyXG4iXX0=