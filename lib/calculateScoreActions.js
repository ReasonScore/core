"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateScoreActions = calculateScoreActions;

var _Score = require("./dataModels/Score");

var _Action = require("./dataModels/Action");

var _calculateScore = require("./calculateScore");

var _RepositoryLocalPure = require("./repositories/RepositoryLocalPure");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Calculates the score actions based on a list of actions
 */
async function calculateScoreActions({
  actions = [],
  repository = new _RepositoryLocalPure.RepositoryLocalPure(),
  calculator = _calculateScore.calculateScore
} = {}) {
  const scoreActions = [];
  const claimIdsToScore = [];
  const ScoreTreeIds = [];
  await repository.notify(actions);

  for (const action of actions) {
    // find claims that may need scores changed
    if (action.type == 'add_claim' || action.type == 'modify_claim') {
      claimIdsToScore.push(action.dataId);
    }

    if (action.type == "add_score") {
      let score = action.newData;

      if (!score.parentId) {
        const scoreTemp = await repository.getScore(action.dataId);

        if (scoreTemp) {
          score = scoreTemp;
        }
      }

      claimIdsToScore.push(score.sourceClaimId);
    } //Add scores if edges adds new children to claims in score trees


    if (action.type == 'add_claimEdge' || action.type == 'modify_claimEdge') {
      let claimEdge = action.newData;

      if (!claimEdge.parentId) {
        const claimEdgeTemp = await repository.getClaimEdge(action.dataId);

        if (claimEdgeTemp) {
          claimEdge = claimEdgeTemp;
        }
      }

      claimIdsToScore.push(claimEdge.parentId);
    } //TODO: If an edge changes then modify the existing scores to match


    if (action.type == 'modify_claimEdge') {
      let claimEdge = await repository.getClaimEdge(action.dataId);
      claimEdge = _objectSpread({}, claimEdge, {}, action.newData);

      if (claimEdge) {
        action.newData;
        const scores = await repository.getScoresBySourceId(claimEdge.id);

        for (const score of scores) {
          //TODO: Where should I put this? It is modifying am object. If it is reactive i should just change the data. If pure it should be a new object.
          //For now I will modify it but it may not trigger updates in a pure library (React)
          //This change should also probably be centralized somewhere to reduce the chance of inconsistent bugs. I think it will happen in multiple paces
          //Nope, it is an action so it should always be a new object. If it goes into a reactive respoitory then it will modify the actual object
          //Should I group these actions or just throw them in one at a time like I am doing
          if (score.pro != claimEdge.pro || score.affects != claimEdge.affects) {
            const action = new _Action.Action({
              pro: claimEdge.pro,
              affects: claimEdge.affects,
              priority: claimEdge.priority
            }, score, "modify_score", score.id);
            scoreActions.push(action);
            await repository.notify([action]);
          }
        }
      }
    }

    if (action.type == 'delete_claimEdge') {
      const oldClaimEdge = action.oldData;
      claimIdsToScore.push(oldClaimEdge.parentId);
    }

    if (action.type == 'add_scoreTree') {
      const scoreTree = action.newData;
      ScoreTreeIds.push(scoreTree.id);
    }
  } //Walk up the scores for each claim to the top


  for (const claimId of claimIdsToScore) {
    for (const claimScore of await repository.getScoresBySourceId(claimId)) {
      ScoreTreeIds.push(claimScore.scoreTreeId);
    }
  } //Re-calc all Score Trees with possible changed claims


  for (const scoreTreeId of ScoreTreeIds) {
    const scoreTree = await repository.getScoreTree(scoreTreeId);

    if (scoreTree) {
      const tempMissingScoreActions = [];
      let topScore = await repository.getScore(scoreTree.topScoreId);

      if (!topScore) {
        topScore = new _Score.Score(scoreTree.sourceClaimId, scoreTree.id);
        topScore.id = scoreTree.topScoreId;
        tempMissingScoreActions.push(new _Action.Action(topScore, undefined, "add_score"));
      }

      await createBlankMissingScores(repository, scoreTree.topScoreId, scoreTree.sourceClaimId || "", tempMissingScoreActions, scoreTreeId);

      if (tempMissingScoreActions.length > 0) {
        await repository.notify(tempMissingScoreActions);
      }

      const tempcalculateScoreTreeActions = [];
      await calculateScoreTree(repository, topScore, calculator, tempMissingScoreActions);
      scoreActions.push(...tempMissingScoreActions, ...tempcalculateScoreTreeActions);
    }
  } //TODO: Review this decision: Feed the score actions back into the repository so this repository is up to date in case it is used 


  await repository.notify(scoreActions);
  return scoreActions;
} //Create Blank Missing Scores


async function createBlankMissingScores(repository, currentScoreId, currentClaimId, actions, scoreTreeId) {
  const edges = await repository.getClaimEdgesByParentId(currentClaimId);
  const scores = await repository.getChildrenByScoreId(currentScoreId);

  for (const edge of edges) {
    //see if there is a matching child score for the child edge
    let score = scores.find(({
      sourceClaimId
    }) => sourceClaimId === edge.childId);

    if (!score) {
      //Create a new Score and attach it to it's parent
      const u = undefined;
      score = new _Score.Score(edge.childId, scoreTreeId, currentScoreId, edge.id, undefined, edge.pro, edge.affects, u, u, u, edge.priority);
      actions.push(new _Action.Action(score, undefined, "add_score", score.id));
    } //Recurse and through children


    await createBlankMissingScores(repository, score.id, edge.childId, actions, scoreTreeId);
  }
} //This function assume that all scores already exist


async function calculateScoreTree(repository, currentScore, calculator = _calculateScore.calculateScore, actions) {
  const oldScores = await repository.getChildrenByScoreId(currentScore.id);
  const newScores = [];

  for (const oldScore of oldScores) {
    //Calculate Children
    //TODO: remove any scores to calculate based on formulas that exclude scores
    newScores.push((await calculateScoreTree(repository, oldScore, calculator, actions)));
  }

  const newScoreFragment = calculator({
    childScores: newScores
  }); //TODO: Modify the newScore based on any formulas

  const newScore = _objectSpread({}, currentScore, {}, newScoreFragment);

  if ((0, _Score.differentScores)(currentScore, newScore)) {
    actions.push(new _Action.Action(newScore, undefined, "modify_score", newScore.id));
  }

  return newScore;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jYWxjdWxhdGVTY29yZUFjdGlvbnMudHMiXSwibmFtZXMiOlsiY2FsY3VsYXRlU2NvcmVBY3Rpb25zIiwiYWN0aW9ucyIsInJlcG9zaXRvcnkiLCJSZXBvc2l0b3J5TG9jYWxQdXJlIiwiY2FsY3VsYXRvciIsImNhbGN1bGF0ZVNjb3JlIiwic2NvcmVBY3Rpb25zIiwiY2xhaW1JZHNUb1Njb3JlIiwiU2NvcmVUcmVlSWRzIiwibm90aWZ5IiwiYWN0aW9uIiwidHlwZSIsInB1c2giLCJkYXRhSWQiLCJzY29yZSIsIm5ld0RhdGEiLCJwYXJlbnRJZCIsInNjb3JlVGVtcCIsImdldFNjb3JlIiwic291cmNlQ2xhaW1JZCIsImNsYWltRWRnZSIsImNsYWltRWRnZVRlbXAiLCJnZXRDbGFpbUVkZ2UiLCJzY29yZXMiLCJnZXRTY29yZXNCeVNvdXJjZUlkIiwiaWQiLCJwcm8iLCJhZmZlY3RzIiwiQWN0aW9uIiwicHJpb3JpdHkiLCJvbGRDbGFpbUVkZ2UiLCJvbGREYXRhIiwic2NvcmVUcmVlIiwiY2xhaW1JZCIsImNsYWltU2NvcmUiLCJzY29yZVRyZWVJZCIsImdldFNjb3JlVHJlZSIsInRlbXBNaXNzaW5nU2NvcmVBY3Rpb25zIiwidG9wU2NvcmUiLCJ0b3BTY29yZUlkIiwiU2NvcmUiLCJ1bmRlZmluZWQiLCJjcmVhdGVCbGFua01pc3NpbmdTY29yZXMiLCJsZW5ndGgiLCJ0ZW1wY2FsY3VsYXRlU2NvcmVUcmVlQWN0aW9ucyIsImNhbGN1bGF0ZVNjb3JlVHJlZSIsImN1cnJlbnRTY29yZUlkIiwiY3VycmVudENsYWltSWQiLCJlZGdlcyIsImdldENsYWltRWRnZXNCeVBhcmVudElkIiwiZ2V0Q2hpbGRyZW5CeVNjb3JlSWQiLCJlZGdlIiwiZmluZCIsImNoaWxkSWQiLCJ1IiwiY3VycmVudFNjb3JlIiwib2xkU2NvcmVzIiwibmV3U2NvcmVzIiwib2xkU2NvcmUiLCJuZXdTY29yZUZyYWdtZW50IiwiY2hpbGRTY29yZXMiLCJuZXdTY29yZSJd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M0MsVUFBbEMsRUFBMkRxRCxZQUEzRCxFQUFpRm5ELFVBQTJCLEdBQUdDLDhCQUEvRyxFQUErSEosT0FBL0gsRUFBa0o7QUFDOUksUUFBTXVELFNBQVMsR0FBRyxNQUFNdEQsVUFBVSxDQUFDZ0Qsb0JBQVgsQ0FBZ0NLLFlBQVksQ0FBQzlCLEVBQTdDLENBQXhCO0FBQ0EsUUFBTWdDLFNBQW1CLEdBQUcsRUFBNUI7O0FBRUEsT0FBSyxNQUFNQyxRQUFYLElBQXVCRixTQUF2QixFQUFrQztBQUFFO0FBQ2hDO0FBQ0FDLElBQUFBLFNBQVMsQ0FBQzdDLElBQVYsRUFBZSxNQUFNaUMsa0JBQWtCLENBQUMzQyxVQUFELEVBQWF3RCxRQUFiLEVBQXVCdEQsVUFBdkIsRUFBbUNILE9BQW5DLENBQXZDO0FBQ0g7O0FBRUQsUUFBTTBELGdCQUFnQixHQUFHdkQsVUFBVSxDQUFDO0FBQ2hDd0QsSUFBQUEsV0FBVyxFQUFFSDtBQURtQixHQUFELENBQW5DLENBVDhJLENBYTlJOztBQUNBLFFBQU1JLFFBQVEscUJBQVFOLFlBQVIsTUFBeUJJLGdCQUF6QixDQUFkOztBQUNBLE1BQUksNEJBQWdCSixZQUFoQixFQUE4Qk0sUUFBOUIsQ0FBSixFQUE2QztBQUN6QzVELElBQUFBLE9BQU8sQ0FBQ1csSUFBUixDQUFhLElBQUlnQixjQUFKLENBQVdpQyxRQUFYLEVBQXFCcEIsU0FBckIsRUFBZ0MsY0FBaEMsRUFBZ0RvQixRQUFRLENBQUNwQyxFQUF6RCxDQUFiO0FBQ0g7O0FBQ0QsU0FBT29DLFFBQVA7QUFDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNjb3JlLCBkaWZmZXJlbnRTY29yZXMsIGlTY29yZSB9IGZyb20gXCIuL2RhdGFNb2RlbHMvU2NvcmVcIjtcclxuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSBcIi4vZGF0YU1vZGVscy9BY3Rpb25cIjtcclxuaW1wb3J0IHsgaUNhbGN1bGF0ZVNjb3JlLCBjYWxjdWxhdGVTY29yZSB9IGZyb20gXCIuL2NhbGN1bGF0ZVNjb3JlXCI7XHJcbmltcG9ydCB7IGlSZXBvc2l0b3J5IH0gZnJvbSBcIi4vZGF0YU1vZGVscy9pUmVwb3NpdG9yeVwiO1xyXG5pbXBvcnQgeyBDbGFpbUVkZ2UsIGlDbGFpbUVkZ2UgfSBmcm9tIFwiLi9kYXRhTW9kZWxzL0NsYWltRWRnZVwiO1xyXG5pbXBvcnQgeyBSZXBvc2l0b3J5TG9jYWxQdXJlIH0gZnJvbSBcIi4vcmVwb3NpdG9yaWVzL1JlcG9zaXRvcnlMb2NhbFB1cmVcIjtcclxuaW1wb3J0IHsgU2NvcmVUcmVlIH0gZnJvbSBcIi5cIjtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzY29yZSBhY3Rpb25zIGJhc2VkIG9uIGEgbGlzdCBvZiBhY3Rpb25zXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlU2NvcmVBY3Rpb25zKHsgYWN0aW9ucyA9IFtdLCByZXBvc2l0b3J5ID0gbmV3IFJlcG9zaXRvcnlMb2NhbFB1cmUoKSwgY2FsY3VsYXRvciA9IGNhbGN1bGF0ZVNjb3JlIH06IHtcclxuICAgIC8qKiBBbiBhcnJheSBvZiBhY3Rpb25zLCB1c3VhbGx5IG9uIGNsYWltcyBvciBlZGdlcyB0aGF0IGluY2x1c2Ugbm8gc2NvcmVzKi9cclxuICAgIGFjdGlvbnM/OiBBY3Rpb25bXTtcclxuICAgIC8qKiBUaGUgcmVwb3NpdG9yeSB1c2VkIHRvIGdldCBjb250ZXh0IGZvciB0aGUgYWN0aW9ucyAqL1xyXG4gICAgcmVwb3NpdG9yeT86IGlSZXBvc2l0b3J5O1xyXG4gICAgLyoqIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgc2NvcmVzICovXHJcbiAgICBjYWxjdWxhdG9yPzogaUNhbGN1bGF0ZVNjb3JlO1xyXG59ID0ge30sXHJcbikge1xyXG4gICAgY29uc3Qgc2NvcmVBY3Rpb25zOiBBY3Rpb25bXSA9IFtdO1xyXG4gICAgY29uc3QgY2xhaW1JZHNUb1Njb3JlOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgY29uc3QgU2NvcmVUcmVlSWRzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgIGF3YWl0IHJlcG9zaXRvcnkubm90aWZ5KGFjdGlvbnMpO1xyXG4gICAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xyXG5cclxuICAgICAgICAvLyBmaW5kIGNsYWltcyB0aGF0IG1heSBuZWVkIHNjb3JlcyBjaGFuZ2VkXHJcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlID09ICdhZGRfY2xhaW0nIHx8IGFjdGlvbi50eXBlID09ICdtb2RpZnlfY2xhaW0nKSB7XHJcbiAgICAgICAgICAgIGNsYWltSWRzVG9TY29yZS5wdXNoKGFjdGlvbi5kYXRhSWQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT0gXCJhZGRfc2NvcmVcIikge1xyXG4gICAgICAgICAgICBsZXQgc2NvcmUgPSBhY3Rpb24ubmV3RGF0YSBhcyBpU2NvcmU7XHJcbiAgICAgICAgICAgIGlmICghc2NvcmUucGFyZW50SWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjb3JlVGVtcCA9IGF3YWl0IHJlcG9zaXRvcnkuZ2V0U2NvcmUoYWN0aW9uLmRhdGFJZClcclxuICAgICAgICAgICAgICAgIGlmIChzY29yZVRlbXApIHtcclxuICAgICAgICAgICAgICAgICAgICBzY29yZSA9IHNjb3JlVGVtcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2xhaW1JZHNUb1Njb3JlLnB1c2goc2NvcmUuc291cmNlQ2xhaW1JZClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vQWRkIHNjb3JlcyBpZiBlZGdlcyBhZGRzIG5ldyBjaGlsZHJlbiB0byBjbGFpbXMgaW4gc2NvcmUgdHJlZXNcclxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT0gJ2FkZF9jbGFpbUVkZ2UnIHx8IGFjdGlvbi50eXBlID09ICdtb2RpZnlfY2xhaW1FZGdlJykge1xyXG4gICAgICAgICAgICBsZXQgY2xhaW1FZGdlID0gYWN0aW9uLm5ld0RhdGEgYXMgaUNsYWltRWRnZTtcclxuICAgICAgICAgICAgaWYgKCFjbGFpbUVkZ2UucGFyZW50SWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsYWltRWRnZVRlbXAgPSBhd2FpdCByZXBvc2l0b3J5LmdldENsYWltRWRnZShhY3Rpb24uZGF0YUlkKVxyXG4gICAgICAgICAgICAgICAgaWYgKGNsYWltRWRnZVRlbXApIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGFpbUVkZ2UgPSBjbGFpbUVkZ2VUZW1wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNsYWltSWRzVG9TY29yZS5wdXNoKGNsYWltRWRnZS5wYXJlbnRJZClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETzogSWYgYW4gZWRnZSBjaGFuZ2VzIHRoZW4gbW9kaWZ5IHRoZSBleGlzdGluZyBzY29yZXMgdG8gbWF0Y2hcclxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT0gJ21vZGlmeV9jbGFpbUVkZ2UnKSB7XHJcbiAgICAgICAgICAgIGxldCBjbGFpbUVkZ2UgPSBhd2FpdCByZXBvc2l0b3J5LmdldENsYWltRWRnZShhY3Rpb24uZGF0YUlkKVxyXG4gICAgICAgICAgICBjbGFpbUVkZ2UgPSB7IC4uLmNsYWltRWRnZSwgLi4uYWN0aW9uLm5ld0RhdGEgfVxyXG4gICAgICAgICAgICBpZiAoY2xhaW1FZGdlKSB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb24ubmV3RGF0YSBhcyBDbGFpbUVkZ2U7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY29yZXMgPSBhd2FpdCByZXBvc2l0b3J5LmdldFNjb3Jlc0J5U291cmNlSWQoY2xhaW1FZGdlLmlkKVxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzY29yZSBvZiBzY29yZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE86IFdoZXJlIHNob3VsZCBJIHB1dCB0aGlzPyBJdCBpcyBtb2RpZnlpbmcgYW0gb2JqZWN0LiBJZiBpdCBpcyByZWFjdGl2ZSBpIHNob3VsZCBqdXN0IGNoYW5nZSB0aGUgZGF0YS4gSWYgcHVyZSBpdCBzaG91bGQgYmUgYSBuZXcgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vRm9yIG5vdyBJIHdpbGwgbW9kaWZ5IGl0IGJ1dCBpdCBtYXkgbm90IHRyaWdnZXIgdXBkYXRlcyBpbiBhIHB1cmUgbGlicmFyeSAoUmVhY3QpXHJcbiAgICAgICAgICAgICAgICAgICAgLy9UaGlzIGNoYW5nZSBzaG91bGQgYWxzbyBwcm9iYWJseSBiZSBjZW50cmFsaXplZCBzb21ld2hlcmUgdG8gcmVkdWNlIHRoZSBjaGFuY2Ugb2YgaW5jb25zaXN0ZW50IGJ1Z3MuIEkgdGhpbmsgaXQgd2lsbCBoYXBwZW4gaW4gbXVsdGlwbGUgcGFjZXNcclxuICAgICAgICAgICAgICAgICAgICAvL05vcGUsIGl0IGlzIGFuIGFjdGlvbiBzbyBpdCBzaG91bGQgYWx3YXlzIGJlIGEgbmV3IG9iamVjdC4gSWYgaXQgZ29lcyBpbnRvIGEgcmVhY3RpdmUgcmVzcG9pdG9yeSB0aGVuIGl0IHdpbGwgbW9kaWZ5IHRoZSBhY3R1YWwgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgLy9TaG91bGQgSSBncm91cCB0aGVzZSBhY3Rpb25zIG9yIGp1c3QgdGhyb3cgdGhlbSBpbiBvbmUgYXQgYSB0aW1lIGxpa2UgSSBhbSBkb2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29yZS5wcm8gIT0gY2xhaW1FZGdlLnBybyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29yZS5hZmZlY3RzICE9IGNsYWltRWRnZS5hZmZlY3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IG5ldyBBY3Rpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvOiBjbGFpbUVkZ2UucHJvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0czogY2xhaW1FZGdlLmFmZmVjdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogY2xhaW1FZGdlLnByaW9yaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBzY29yZSwgXCJtb2RpZnlfc2NvcmVcIiwgc2NvcmUuaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlQWN0aW9ucy5wdXNoKGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlcG9zaXRvcnkubm90aWZ5KFthY3Rpb25dKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PSAnZGVsZXRlX2NsYWltRWRnZScpIHtcclxuICAgICAgICAgICAgY29uc3Qgb2xkQ2xhaW1FZGdlID0gYWN0aW9uLm9sZERhdGEgYXMgQ2xhaW1FZGdlO1xyXG4gICAgICAgICAgICBjbGFpbUlkc1RvU2NvcmUucHVzaChvbGRDbGFpbUVkZ2UucGFyZW50SWQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT0gJ2FkZF9zY29yZVRyZWUnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjb3JlVHJlZSA9IGFjdGlvbi5uZXdEYXRhIGFzIFNjb3JlVHJlZTtcclxuICAgICAgICAgICAgU2NvcmVUcmVlSWRzLnB1c2goc2NvcmVUcmVlLmlkKVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICAvL1dhbGsgdXAgdGhlIHNjb3JlcyBmb3IgZWFjaCBjbGFpbSB0byB0aGUgdG9wXHJcbiAgICBmb3IgKGNvbnN0IGNsYWltSWQgb2YgY2xhaW1JZHNUb1Njb3JlKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjbGFpbVNjb3JlIG9mIGF3YWl0IHJlcG9zaXRvcnkuZ2V0U2NvcmVzQnlTb3VyY2VJZChjbGFpbUlkKSkge1xyXG4gICAgICAgICAgICAgICAgU2NvcmVUcmVlSWRzLnB1c2goY2xhaW1TY29yZS5zY29yZVRyZWVJZClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9SZS1jYWxjIGFsbCBTY29yZSBUcmVlcyB3aXRoIHBvc3NpYmxlIGNoYW5nZWQgY2xhaW1zXHJcbiAgICBmb3IgKGNvbnN0IHNjb3JlVHJlZUlkIG9mIFNjb3JlVHJlZUlkcykge1xyXG4gICAgICAgIGNvbnN0IHNjb3JlVHJlZSA9IGF3YWl0IHJlcG9zaXRvcnkuZ2V0U2NvcmVUcmVlKHNjb3JlVHJlZUlkKVxyXG4gICAgICAgIGlmIChzY29yZVRyZWUpIHtcclxuICAgICAgICAgICAgY29uc3QgdGVtcE1pc3NpbmdTY29yZUFjdGlvbnM6IEFjdGlvbltdID0gW107XHJcblxyXG4gICAgICAgICAgICBsZXQgdG9wU2NvcmUgPSBhd2FpdCByZXBvc2l0b3J5LmdldFNjb3JlKHNjb3JlVHJlZS50b3BTY29yZUlkKTtcclxuICAgICAgICAgICAgaWYgKCF0b3BTY29yZSl7XHJcbiAgICAgICAgICAgICAgICB0b3BTY29yZSA9IG5ldyBTY29yZShzY29yZVRyZWUuc291cmNlQ2xhaW1JZCxzY29yZVRyZWUuaWQpO1xyXG4gICAgICAgICAgICAgICAgdG9wU2NvcmUuaWQgPSBzY29yZVRyZWUudG9wU2NvcmVJZDtcclxuICAgICAgICAgICAgICAgIHRlbXBNaXNzaW5nU2NvcmVBY3Rpb25zLnB1c2gobmV3IEFjdGlvbih0b3BTY29yZSx1bmRlZmluZWQsXCJhZGRfc2NvcmVcIikpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBjcmVhdGVCbGFua01pc3NpbmdTY29yZXMocmVwb3NpdG9yeSwgc2NvcmVUcmVlLnRvcFNjb3JlSWQsIHNjb3JlVHJlZS5zb3VyY2VDbGFpbUlkIHx8IFwiXCIsIHRlbXBNaXNzaW5nU2NvcmVBY3Rpb25zLCBzY29yZVRyZWVJZClcclxuICAgICAgICAgICAgaWYgKHRlbXBNaXNzaW5nU2NvcmVBY3Rpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHJlcG9zaXRvcnkubm90aWZ5KHRlbXBNaXNzaW5nU2NvcmVBY3Rpb25zKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbXBjYWxjdWxhdGVTY29yZVRyZWVBY3Rpb25zOiBBY3Rpb25bXSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgY2FsY3VsYXRlU2NvcmVUcmVlKHJlcG9zaXRvcnksIHRvcFNjb3JlLCBjYWxjdWxhdG9yLCB0ZW1wTWlzc2luZ1Njb3JlQWN0aW9ucyk7XHJcbiAgICAgICAgICAgIHNjb3JlQWN0aW9ucy5wdXNoKC4uLnRlbXBNaXNzaW5nU2NvcmVBY3Rpb25zLCAuLi50ZW1wY2FsY3VsYXRlU2NvcmVUcmVlQWN0aW9ucylcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9UT0RPOiBSZXZpZXcgdGhpcyBkZWNpc2lvbjogRmVlZCB0aGUgc2NvcmUgYWN0aW9ucyBiYWNrIGludG8gdGhlIHJlcG9zaXRvcnkgc28gdGhpcyByZXBvc2l0b3J5IGlzIHVwIHRvIGRhdGUgaW4gY2FzZSBpdCBpcyB1c2VkIFxyXG4gICAgYXdhaXQgcmVwb3NpdG9yeS5ub3RpZnkoc2NvcmVBY3Rpb25zKTtcclxuXHJcbiAgICByZXR1cm4gc2NvcmVBY3Rpb25zO1xyXG59XHJcblxyXG4vL0NyZWF0ZSBCbGFuayBNaXNzaW5nIFNjb3Jlc1xyXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVCbGFua01pc3NpbmdTY29yZXMocmVwb3NpdG9yeTogaVJlcG9zaXRvcnksIGN1cnJlbnRTY29yZUlkOiBzdHJpbmcsIGN1cnJlbnRDbGFpbUlkOiBzdHJpbmcsIGFjdGlvbnM6IEFjdGlvbltdLCBzY29yZVRyZWVJZDogc3RyaW5nKSB7XHJcbiAgICBjb25zdCBlZGdlcyA9IGF3YWl0IHJlcG9zaXRvcnkuZ2V0Q2xhaW1FZGdlc0J5UGFyZW50SWQoY3VycmVudENsYWltSWQpXHJcbiAgICBjb25zdCBzY29yZXMgPSBhd2FpdCByZXBvc2l0b3J5LmdldENoaWxkcmVuQnlTY29yZUlkKGN1cnJlbnRTY29yZUlkKVxyXG4gICAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XHJcbiAgICAgICAgLy9zZWUgaWYgdGhlcmUgaXMgYSBtYXRjaGluZyBjaGlsZCBzY29yZSBmb3IgdGhlIGNoaWxkIGVkZ2VcclxuICAgICAgICBsZXQgc2NvcmUgPSBzY29yZXMuZmluZCgoeyBzb3VyY2VDbGFpbUlkIH0pID0+IHNvdXJjZUNsYWltSWQgPT09IGVkZ2UuY2hpbGRJZCk7XHJcbiAgICAgICAgaWYgKCFzY29yZSkge1xyXG4gICAgICAgICAgICAvL0NyZWF0ZSBhIG5ldyBTY29yZSBhbmQgYXR0YWNoIGl0IHRvIGl0J3MgcGFyZW50XHJcbiAgICAgICAgICAgIGNvbnN0IHUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHNjb3JlID0gbmV3IFNjb3JlKGVkZ2UuY2hpbGRJZCwgc2NvcmVUcmVlSWQsIGN1cnJlbnRTY29yZUlkLCBlZGdlLmlkLCB1bmRlZmluZWQsIGVkZ2UucHJvLCBlZGdlLmFmZmVjdHMsdSx1LHUsZWRnZS5wcmlvcml0eSk7XHJcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChuZXcgQWN0aW9uKHNjb3JlLCB1bmRlZmluZWQsIFwiYWRkX3Njb3JlXCIsIHNjb3JlLmlkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vUmVjdXJzZSBhbmQgdGhyb3VnaCBjaGlsZHJlblxyXG4gICAgICAgIGF3YWl0IGNyZWF0ZUJsYW5rTWlzc2luZ1Njb3JlcyhyZXBvc2l0b3J5LCBzY29yZS5pZCwgZWRnZS5jaGlsZElkLCBhY3Rpb25zLCBzY29yZVRyZWVJZCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vVGhpcyBmdW5jdGlvbiBhc3N1bWUgdGhhdCBhbGwgc2NvcmVzIGFscmVhZHkgZXhpc3RcclxuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlU2NvcmVUcmVlKHJlcG9zaXRvcnk6IGlSZXBvc2l0b3J5LCBjdXJyZW50U2NvcmU6IGlTY29yZSwgY2FsY3VsYXRvcjogaUNhbGN1bGF0ZVNjb3JlID0gY2FsY3VsYXRlU2NvcmUsIGFjdGlvbnM6IEFjdGlvbltdKSB7XHJcbiAgICBjb25zdCBvbGRTY29yZXMgPSBhd2FpdCByZXBvc2l0b3J5LmdldENoaWxkcmVuQnlTY29yZUlkKGN1cnJlbnRTY29yZS5pZClcclxuICAgIGNvbnN0IG5ld1Njb3JlczogaVNjb3JlW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG9sZFNjb3JlIG9mIG9sZFNjb3JlcykgeyAvL0NhbGN1bGF0ZSBDaGlsZHJlblxyXG4gICAgICAgIC8vVE9ETzogcmVtb3ZlIGFueSBzY29yZXMgdG8gY2FsY3VsYXRlIGJhc2VkIG9uIGZvcm11bGFzIHRoYXQgZXhjbHVkZSBzY29yZXNcclxuICAgICAgICBuZXdTY29yZXMucHVzaChhd2FpdCBjYWxjdWxhdGVTY29yZVRyZWUocmVwb3NpdG9yeSwgb2xkU2NvcmUsIGNhbGN1bGF0b3IsIGFjdGlvbnMpKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBuZXdTY29yZUZyYWdtZW50ID0gY2FsY3VsYXRvcih7XHJcbiAgICAgICAgY2hpbGRTY29yZXM6IG5ld1Njb3JlcyxcclxuICAgIH0pXHJcblxyXG4gICAgLy9UT0RPOiBNb2RpZnkgdGhlIG5ld1Njb3JlIGJhc2VkIG9uIGFueSBmb3JtdWxhc1xyXG4gICAgY29uc3QgbmV3U2NvcmUgPSB7IC4uLmN1cnJlbnRTY29yZSwgLi4ubmV3U2NvcmVGcmFnbWVudCB9XHJcbiAgICBpZiAoZGlmZmVyZW50U2NvcmVzKGN1cnJlbnRTY29yZSwgbmV3U2NvcmUpKSB7XHJcbiAgICAgICAgYWN0aW9ucy5wdXNoKG5ldyBBY3Rpb24obmV3U2NvcmUsIHVuZGVmaW5lZCwgXCJtb2RpZnlfc2NvcmVcIiwgbmV3U2NvcmUuaWQpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdTY29yZTtcclxufVxyXG4iXX0=